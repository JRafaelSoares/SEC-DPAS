package pt.ulisboa.tecnico.SECDPAS;

/* these are generated by the Contract */
import SECDPAS.grpc.Contract;
import SECDPAS.grpc.DPASServiceGrpc;
import com.google.common.primitives.Bytes;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import com.google.protobuf.ByteString;
import com.google.protobuf.Empty;
import io.grpc.Metadata;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;
import org.apache.commons.lang3.SerializationException;
import org.apache.commons.lang3.SerializationUtils;

import javax.crypto.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.security.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;

public class DPASServiceImpl extends DPASServiceGrpc.DPASServiceImplBase {

	private ConcurrentHashMap<PublicKey, ArrayList<Announcement>> privateBoard = new ConcurrentHashMap<>();
	private ArrayList<Announcement> generalBoard = new ArrayList<>();
	private ConcurrentHashMap<PublicKey, MessageHandler> clientSessions = new ConcurrentHashMap<>();
	private ConcurrentHashMap<Integer, Announcement> announcementIDs = new ConcurrentHashMap<>();

	private String databasePath;

	private PrivateKey privateKey;

	private long initialTime;
	private int announcementID = 0;

	private int serverID;
	/* for debugging change to 1 */
	private int debug = 0;

	public DPASServiceImpl(PrivateKey privateKey, int id) throws DatabaseException{
		this.initialTime = System.currentTimeMillis();

		Path currentRelativePath = Paths.get("");
		this.databasePath = currentRelativePath.toAbsolutePath().toString() + "/src/database";
		this.privateKey = privateKey;
		this.serverID = id;
		load();
	}

	@Override
	public void diffieHellmanExchange(Contract.DHExchangeRequest request, StreamObserver<Contract.DHExchangeResponse> responseObserver){
		if(debug != 0) System.out.println("[SETUP CONNECTION] Request from client.\n");

		byte[] encodedClientKey = request.getPublicKey().toByteArray();
		byte[] clientAgreement = request.getClientAgreement().toByteArray();
		byte[] clientChallenge = request.getClientChallenge().toByteArray();
		byte[] clientSignature = request.getSignature().toByteArray();

		/* Obtaining the Public Key of the Client */
		PublicKey userKey = verifyPublicKey(encodedClientKey, responseObserver, clientChallenge);

		if(userKey == null){
			return;
		}

		/* Message Handler for the Client */
		MessageHandler messageHandler = clientSessions.get(userKey);

		/* If it does not exist, create a new one */
		if(messageHandler == null){
			messageHandler = new MessageHandler(null);
			clientSessions.put(userKey, messageHandler);
		}

		/* Client must be registered. Verify freshness and signature of the request */
		if(!verifyClientIsRegistered(userKey, responseObserver, encodedClientKey, clientChallenge) || !verifySignature(Bytes.concat(encodedClientKey, clientAgreement, clientChallenge), clientSignature, userKey, responseObserver, "ClientSignatureInvalid", encodedClientKey, clientChallenge)){
			return;
		}

		/* Perform server side of the agreement and add a new message handler for the current client's session */
		DiffieHellmanServer dhServer = new DiffieHellmanServer();
		byte[] serverAgreement = dhServer.execute(clientAgreement);

		SecretKey hmacKey = dhServer.getSharedHMACKey();

		/* Preparing response */
		byte[] challenge = FreshnessHandler.generateRandomBytes(8);
		byte[] signature = SignatureHandler.publicSign(Bytes.concat(serverAgreement, clientChallenge, challenge), privateKey);

		messageHandler.prepareNewIntegrityHandler(hmacKey, challenge);

		Contract.DHExchangeResponse response = Contract.DHExchangeResponse.newBuilder().setServerAgreement(ByteString.copyFrom(serverAgreement)).setServerResponse(request.getClientChallenge()).setServerChallenge(ByteString.copyFrom(challenge)).setSignature(ByteString.copyFrom(signature)).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	public void clientHandshake(Contract.ClientHandshakeRequest request, StreamObserver<Contract.ACK> responseObserver){
		byte[] encodedClientKey = request.getPublicKey().toByteArray();
		byte[] clientResponse = request.getClientResponse().toByteArray();
		byte[] clientHMAC = request.getSignature().toByteArray();

		/* Obtaining the Public Key of the Client */
		PublicKey userKey = verifyPublicKey(encodedClientKey, responseObserver, clientResponse);

		if(userKey == null){
			return;
		}

		/* Message Handler for the Client */
		MessageHandler messageHandler = clientSessions.get(userKey);

		/* If it does not exist, the first step of the handshake was not performed */
		if(messageHandler == null){
			if(debug != 0) System.out.println("\t ERROR: UNAUTHENTICATED - SessionNotInitiated. (First step of handshake not performed)");
			responseObserver.onError(buildException(Status.Code.UNAUTHENTICATED, "SessionNotInitiated", encodedClientKey, clientResponse));
			return;
		}

		/* Client must be registered. Verify freshness and signature of the request */
		if(!verifyClientIsRegistered(userKey, responseObserver, encodedClientKey, clientResponse) || !verifyPreparingIntegrity(messageHandler, responseObserver, encodedClientKey, clientHMAC, encodedClientKey, clientResponse)){
			return;
		}

		if(!messageHandler.completePreparation(clientResponse)){
			if(debug != 0) System.out.println("\t ERROR: UNAUTHENTICATED - SessionNotInitiated. (ClientResponse doesn't check out)");
			responseObserver.onError(buildException(Status.Code.UNAUTHENTICATED, "SessionNotInitiated", encodedClientKey, clientResponse));
			return;
		}

		byte[] integrity = messageHandler.calculateHMAC(new byte[0], clientResponse);

		Contract.ACK response = Contract.ACK.newBuilder().setFreshness(ByteString.copyFrom(clientResponse)).setSignature(ByteString.copyFrom(integrity)).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void closeSession(Contract.CloseSessionRequest request, StreamObserver<Contract.ACK> responseObserver){
		if(debug != 0) System.out.println("[CLOSE SESSION] Request from client.\n");

		byte[] serializedPublicKey = request.getPublicKey().toByteArray();
		byte[] freshness = request.getFreshness().toByteArray();
		byte[] signature = request.getSignature().toByteArray();

		/* Obtaining the Public Key of the Client */
		PublicKey userKey = verifyPublicKey(serializedPublicKey, responseObserver, freshness);

		if(userKey == null){
			return;
		}

		MessageHandler messageHandler = clientSessions.get(userKey);

		/* Client must be registered. Client must be in session. Verify freshness and signature of the request */
		if(!verifyClientIsRegistered(userKey, responseObserver, serializedPublicKey, freshness) || !verifyIsInSession(messageHandler, responseObserver, serializedPublicKey, freshness) || !verifyMessage(messageHandler, responseObserver, serializedPublicKey, signature, serializedPublicKey, freshness)){
			return;
		}

		responseObserver.onNext(buildACKresponse(messageHandler, "hmac"));

		/* Closing session */
		messageHandler.resetHMAC(null);

		responseObserver.onCompleted();
	}

	@Override
	public void register(Contract.RegisterRequest request, StreamObserver<Contract.ACK> responseObserver) {
		if(debug != 0) System.out.println("[REGISTER] Request from client.\n");

		byte[] encodedClientKey = request.getPublicKey().toByteArray();
		byte[] clientSignature = request.getSignature().toByteArray();

		/* Obtaining the Public Key of the Client */
		PublicKey userKey = verifyPublicKey(encodedClientKey, responseObserver, new byte[0]);

		if(userKey == null){
			return;
		}

		MessageHandler messageHandler = new MessageHandler(null);

		/* Client must NOT be registered. Verify freshness and signature of the request. */
		if(verifyClientIsAlreadyRegistered(userKey, responseObserver, encodedClientKey, new byte[0]) || !verifySignature(Bytes.concat(encodedClientKey, new byte[0]), clientSignature, userKey, responseObserver, "ClientSignatureInvalid", encodedClientKey, new byte[0])){
			return;
		}

		/* Registering client */
		this.privateBoard.put(userKey, new ArrayList<>());
		this.clientSessions.put(userKey, messageHandler);

		/* Saving posts */
		try{
			save("posts");
		}catch (DatabaseException e){
			System.out.println("[REGISTER] ERROR - DatabaseException -  " + e.getMessage() + "\n");
		}

		byte[] freshness = new byte[0];
		byte[] signature = SignatureHandler.publicSign(freshness, this.privateKey);

		responseObserver.onNext(Contract.ACK.newBuilder().setFreshness(ByteString.copyFrom(freshness)).setSignature(ByteString.copyFrom(signature)).build());
		responseObserver.onCompleted();
	}

	@Override
	public void post(Contract.PostRequest request, StreamObserver<Contract.ACK> responseObserver) {
		if(debug != 0) System.out.println("[SERVER] Post request from client.\n");

		/* Verify request */
		byte[] postBytes = verifyPostRequest(request, responseObserver);

		/* In case the request is faulty */
		if(postBytes == null){
			return;
		}

		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		String[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		MessageHandler messageHandler = clientSessions.get(userKey);

		/* create post */
		char[] post = new String(postBytes, StandardCharsets.UTF_8).toCharArray();
		ArrayList<Announcement> announcementList = this.privateBoard.get(userKey);

		int announcementID = addCounter();
		Announcement announcement = new Announcement(post, userKey, announcements, announcementID, request.getMessageSignature().toByteArray());

		synchronized (this) {
			announcementList.add(announcement);
		}

		this.announcementIDs.put(announcementID, announcement);

		/* Save posts */
		try{
			save("posts");
		} catch (DatabaseException e){
			e.getCause();
		}

		responseObserver.onNext(buildACKresponse(messageHandler, "hmac"));
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneral(Contract.PostRequest request, StreamObserver<Contract.ACK> responseObserver) {
		if(debug != 0) System.out.println("[SERVER] PostGeneral request from client.\n");

		/* Verify request */
		byte[] postBytes = verifyPostRequest(request, responseObserver);

		/* In case the request is faulty */
		if(postBytes == null){
			return;
		}

		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		String[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		MessageHandler messageHandler = clientSessions.get(userKey);

		/* create post */
		char[] post = new String(postBytes, StandardCharsets.UTF_8).toCharArray();

		int announcementID = addCounter();
		Announcement announcement = new Announcement(post, userKey, announcements, announcementID, request.getMessageSignature().toByteArray());
		
		synchronized(this) {
			this.generalBoard.add(announcement);
		}
		this.announcementIDs.put(announcementID, announcement);

		/* Save posts */
		try{
			save("generalPosts");
		}catch (DatabaseException e){
			e.getCause();
		}

		responseObserver.onNext(buildACKresponse(messageHandler, "hmac"));
		responseObserver.onCompleted();
	}

	@Override
	public void read(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		byte[] serializedTargetPublicKey = request.getTargetPublicKey().toByteArray();
		byte[] serializedClientPublicKey = request.getClientPublicKey().toByteArray();

		int numPosts = request.getNumber();
		byte[] number = Ints.toByteArray(numPosts);
		byte[] freshness = request.getFreshness().toByteArray();
		byte[] signature = request.getSignature().toByteArray();

		PublicKey targetUserKey = verifyPublicKey(serializedTargetPublicKey, responseObserver, freshness);

		/* Target is valid. Client must be registered. */
		if(targetUserKey == null || !verifyClientIsRegistered(targetUserKey, responseObserver, serializedClientPublicKey, freshness)){
			return;
		}

		PublicKey clientUserKey = verifyPublicKey(serializedClientPublicKey, responseObserver, freshness);

		/* Client is valid. Client must be registered. */
		if(clientUserKey == null || !verifyClientIsRegistered(clientUserKey, responseObserver, serializedClientPublicKey, freshness)){
			return;
		}

		MessageHandler messageHandler = clientSessions.get(clientUserKey);

		/* Client is in session. Verify freshness and integrity-signature */
		if(!verifyIsInSession(messageHandler, responseObserver, serializedClientPublicKey, freshness) || !verifyMessage(messageHandler, responseObserver, Bytes.concat(serializedTargetPublicKey, serializedClientPublicKey, number), signature, serializedClientPublicKey, freshness)){
			return;
		}

		/* Prepare announcements */
		ArrayList<Announcement> announcementList = this.privateBoard.get(targetUserKey);

		byte[] responseAnnouncements;
		if(numPosts == 0 || numPosts > announcementList.size()){
			responseAnnouncements = SerializationUtils.serialize(announcementList.toArray(new Announcement[0]));
		}
		else{
			List<Announcement> toSend =  announcementList.subList(announcementList.size() - numPosts, announcementList.size());
			Announcement[] announcements = toSend.toArray(new Announcement[0]);

			responseAnnouncements = SerializationUtils.serialize(announcements);
		}


		responseObserver.onNext(buildReadResponse(messageHandler, responseAnnouncements));
		responseObserver.onCompleted();
	}

	@Override
	public void readGeneral(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		byte[] serializedClientPublicKey = request.getClientPublicKey().toByteArray();
		int numPosts = request.getNumber();
		byte[] number = Ints.toByteArray(numPosts);
		byte[] freshness = request.getFreshness().toByteArray();
		byte[] signature = request.getSignature().toByteArray();

		PublicKey clientUserKey = verifyPublicKey(serializedClientPublicKey, responseObserver, freshness);

		/* Client is valid. Client must be registered. */
		if(clientUserKey == null || !verifyClientIsRegistered(clientUserKey, responseObserver, serializedClientPublicKey, freshness)){
			return;
		}

		MessageHandler messageHandler = clientSessions.get(clientUserKey);

		/* Client is in session. Verify freshness and integrity-signature */
		if(!verifyIsInSession(messageHandler, responseObserver, serializedClientPublicKey, freshness) || !verifyMessage(messageHandler, responseObserver, Bytes.concat(serializedClientPublicKey, number), signature, serializedClientPublicKey, freshness)){
			return;
		}

		/* Prepare announcements */
		byte[] responseAnnouncements;

		if(numPosts == 0 || numPosts > this.generalBoard.size()){
			responseAnnouncements = SerializationUtils.serialize(this.generalBoard.toArray(new Announcement[0]));
		}
		else{
			List<Announcement> toSent =  this.generalBoard.subList(this.generalBoard.size() - numPosts, this.generalBoard.size());
			responseAnnouncements = SerializationUtils.serialize(toSent.toArray(new Announcement[0]));
		}

		responseObserver.onNext(buildReadResponse(messageHandler, responseAnnouncements));
		responseObserver.onCompleted();
	}

	private synchronized void save(String file) throws DatabaseException{
		try {

			FileOutputStream myWriter = new FileOutputStream(this.databasePath + "/" + file + "_try.txt");

			/* write in file */
			switch (file) {
				case "posts":
						myWriter.write(SerializationUtils.serialize(privateBoard));
					break;
				case "generalPosts":
						myWriter.write(SerializationUtils.serialize(generalBoard));
					break;
			}
			myWriter.close();

			/* File successfully created, transferring to official file */
			Path src = Paths.get(this.databasePath + "/" + file + "_try.txt");
			Path dst = Paths.get(this.databasePath + "/" + file + ".txt");

			Files.move(src, dst, StandardCopyOption.ATOMIC_MOVE);
			//Saves the IDs persistently
			saveIDs();
		} catch (IOException e) {
			throw new DatabaseException("Unable to save: " + e.getMessage());
		}

	}

	private void saveIDs() throws DatabaseException{
		try {
			FileOutputStream myWriter = new FileOutputStream(this.databasePath + "/announcementsID_try.txt");
			myWriter.write(SerializationUtils.serialize(this.announcementIDs));
			myWriter.close();

			/* File successfully created, transferring to official file */
			Path src = Paths.get(this.databasePath + "/announcementsID_try.txt");
			Path dst = Paths.get(this.databasePath + "/announcementsID.txt");

			Files.move(src, dst, StandardCopyOption.ATOMIC_MOVE);

		} catch (IOException e) {
			throw new DatabaseException("Unable to save: " + e.getMessage());
		}


	}

	private synchronized void load() throws DatabaseException{
		try {
			if (new File(this.databasePath + "/posts.txt").exists()) {
				/* read from file posts */
				FileInputStream myReader = new FileInputStream(this.databasePath + "/posts.txt");
				this.privateBoard = SerializationUtils.deserialize(myReader.readAllBytes());
				for(PublicKey key: this.privateBoard.keySet()){
					this.clientSessions.put(key, new MessageHandler(null));
				}
				myReader.close();
			}
			if (new File(this.databasePath + "/generalPosts.txt").exists()) {
				/* read from file generalPosts */
				FileInputStream myReader = new FileInputStream(this.databasePath + "/generalPosts.txt");
				this.generalBoard = SerializationUtils.deserialize(myReader.readAllBytes());
				myReader.close();
			}
			if(new File(this.databasePath + "/announcementsID.txt").exists()) {
				/* read from file generalPosts */
				FileInputStream myReader = new FileInputStream(this.databasePath + "/announcementsID.txt");
				this.announcementIDs = SerializationUtils.deserialize(myReader.readAllBytes());
				myReader.close();
				this.announcementID = this.announcementIDs.size();
			}


		} catch (IOException e) {
			throw new DatabaseException("Unable to load: " + e.getMessage());
		}
	}

	/************************/
	/** AUXILIAR FUNCTIONS **/
	/************************/

	private byte[] verifyPostRequest(Contract.PostRequest request, StreamObserver<Contract.ACK> responseObserver){
		byte[] serializedPublicKey = request.getPublicKey().toByteArray();
		byte[] encryptedMessage = request.getMessage().toByteArray();
		byte[] messageSignature = request.getMessageSignature().toByteArray();
		byte[] serializedAnnouncements = request.getAnnouncements().toByteArray();
		byte[] freshness = request.getFreshness().toByteArray();
		byte[] signature = request.getSignature().toByteArray();

		/* Obtaining the Public Key of the Client */
		PublicKey userKey = verifyPublicKey(serializedPublicKey, responseObserver, freshness);
		String[] announcements = verifyAnnouncements(serializedAnnouncements, responseObserver, serializedPublicKey, freshness);

		/* Public Key is valid. Announcements are valid. Client must be registered. */
		if(userKey == null || announcements == null || !verifyClientIsRegistered(userKey, responseObserver, serializedPublicKey, freshness)){
			return null;
		}

		MessageHandler messageHandler = clientSessions.get(userKey);

		/* Client is in session. Verify message freshness and integrity-signature. References exists.*/
		if(!verifyIsInSession(messageHandler, responseObserver, serializedPublicKey, freshness) || !verifyMessage(messageHandler, responseObserver, Bytes.concat(serializedPublicKey, encryptedMessage, messageSignature, serializedAnnouncements), signature, serializedPublicKey, freshness) || !verifyReferences(announcements, responseObserver, serializedPublicKey, freshness)){
			return null;
		}

		byte[] serverFreshness = Longs.toByteArray(messageHandler.getFreshness());

		byte[] postBytes = null;
		try {
			Cipher decrypt = Cipher.getInstance("RSA/ECB/PKCS1Padding");
			decrypt.init(Cipher.DECRYPT_MODE, privateKey);
			postBytes = decrypt.doFinal(encryptedMessage);
		} catch (IllegalBlockSizeException | BadPaddingException | NoSuchPaddingException | NoSuchAlgorithmException | InvalidKeyException e) {
			System.out.println("[POST] ERROR - Decrypting -  " + e.getMessage() + "\n");
		}

		/* Verify signature of announcements */
		if(!verifySignature(Bytes.concat(serializedPublicKey, postBytes, serializedAnnouncements), messageSignature, userKey, responseObserver, "AnnouncementSignatureInvalid", serializedPublicKey, freshness)){
			return null;
		}
		return postBytes;
	}

	private PublicKey verifyPublicKey(byte[] serializedPublicKey, StreamObserver<?> responseObserver, byte[] clientFreshness){
		try{
			return SerializationUtils.deserialize(serializedPublicKey);
		}catch(SerializationException e){
			responseObserver.onError(buildException(Status.Code.INVALID_ARGUMENT, "PublicKey", serializedPublicKey, clientFreshness));
			return null;
		}
	}

	private String[] verifyAnnouncements(byte[] serializedAnnouncements, StreamObserver<?> responseObserver, byte[] serializedClientKey, byte[] clientFreshness){
		try{
			return SerializationUtils.deserialize(serializedAnnouncements);
		} catch(SerializationException e){
			responseObserver.onError(buildException(Status.Code.INVALID_ARGUMENT, "PublicKey", serializedClientKey, clientFreshness));
			return null;
		}
	}

	private boolean verifyClientIsRegistered(PublicKey userKey, StreamObserver<?> responseObserver, byte[] serializedClientKey, byte[] clientFreshness) {
		if(!this.privateBoard.containsKey(userKey)){
			if(debug != 0) System.out.println("\t ERROR: PERMISSION_DENIED - ClientNotRegistered.\n");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientNotRegistered", serializedClientKey, clientFreshness));
			return false;
		}
		return true;
	}

	private boolean verifyClientIsAlreadyRegistered(PublicKey userKey, StreamObserver<?> responseObserver, byte[] serializedClientKey, byte[] clientFreshness){
		if(this.privateBoard.get(userKey) != null){
			if(debug != 0) System.out.println("\t ERROR: PERMISSION_DENIED - ClientAlreadyRegistered.");
			responseObserver.onError(buildException(Status.Code.INVALID_ARGUMENT, "ClientAlreadyRegistered", serializedClientKey, clientFreshness));
			return true;
		}
		return false;
	}

	private boolean verifyFreshness(MessageHandler messageHandler, StreamObserver<?> responseObserver, byte[] serializedClientKey, byte[] clientFreshness){
		try {
			messageHandler.verifyFreshness(Longs.fromByteArray(clientFreshness));
		} catch (MessageNotFreshException e) {
			if(debug != 0) System.out.println("\t ERROR: PERMISSION_DENIED - ClientRequestNotFresh.\n");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientRequestNotFresh", serializedClientKey, clientFreshness));
			return false;
		}
		return true;
	}

	private boolean verifySignature(byte[] message, byte[] clientSignature, PublicKey userKey, StreamObserver<?> responseObserver, String error, byte[] serializedClientKey, byte[] clientFreshness){
		if(!SignatureHandler.verifyPublicSignature(message, clientSignature, userKey)){
			if(debug != 0) System.out.println("\t ERROR: PERMISSION_DENIED - " + error + ".\n");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, error, serializedClientKey, clientFreshness));
			//AnnouncementSignatureInvalid
			return false;
		}
		return true;
	}

	private boolean verifyIsInSession(MessageHandler messageHandler, StreamObserver<?> responseObserver, byte[] serializedClientKey, byte[] clientFreshness){
		if(!messageHandler.isInSession()){
			if(debug != 0) System.out.println("\t ERROR: UNAUTHENTICATED - SessionNotInitiated.");
			responseObserver.onError(buildException(Status.Code.UNAUTHENTICATED, "SessionNotInitiated", serializedClientKey, clientFreshness));
			return false;
		}
		return true;
	}

	private boolean verifyMessage(MessageHandler messageHandler, StreamObserver<?> responseObserver, byte[] supposedMessage, byte[] signature, byte[] serializedClientKey, byte[] clientFreshness){
		try {
			messageHandler.verifyMessage(supposedMessage, Longs.fromByteArray(clientFreshness), signature);
		} catch (SignatureNotValidException e) {
			if(debug != 0) System.out.println("\t ERROR: PERMISSION_DENIED - ClientIntegrityViolation.");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientIntegrityViolation", serializedClientKey, clientFreshness));
			return false;
		} catch (MessageNotFreshException e) {
			if(debug != 0) System.out.println("\t ERROR: PERMISSION_DENIED - ClientRequestNotFresh.");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientRequestNotFresh", serializedClientKey, clientFreshness));
			return false;
		}
		return true;
	}

	private boolean verifyPreparingIntegrity(MessageHandler messageHandler, StreamObserver<?> responseObserver, byte[] supposedMessage, byte[] signature, byte[] serializedClientKey, byte[] clientFreshness){
		try {
			messageHandler.verifyPreparingIntegrity(supposedMessage, clientFreshness, signature);
		} catch (SignatureNotValidException e) {
			if(debug != 0) System.out.println("\t ERROR: PERMISSION_DENIED - ClientIntegrityViolation.");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientIntegrityViolation", serializedClientKey, clientFreshness));
			return false;
		}

		return true;
	}

	private boolean verifyReferences(String[] references, StreamObserver<?> responseObserver, byte[] serializedClientKey, byte[] clientFreshness){
		for(String reference: references){
			if(!announcementIDs.containsKey(Integer.valueOf(reference))){
				responseObserver.onError(buildException(Status.Code.INVALID_ARGUMENT, "NonExistentAnnouncementReference", serializedClientKey, clientFreshness));
				return false;
			}
		}
		return true;
	}

	private StatusRuntimeException buildException(Status.Code code, String description, byte[] serializedClientKey, byte[] clientFreshness){
		Status status = Status.fromCode(code).withDescription(description);

		Metadata metadata = new Metadata();

		Metadata.Key<byte[]> clientKey = Metadata.Key.of("clientKey-bin", Metadata.BINARY_BYTE_MARSHALLER);
		Metadata.Key<byte[]> clientFreshnessKey = Metadata.Key.of("clientFreshness-bin", Metadata.BINARY_BYTE_MARSHALLER);
		Metadata.Key<byte[]> signatureKey = Metadata.Key.of("signature-bin", Metadata.BINARY_BYTE_MARSHALLER);

		metadata.put(clientKey, serializedClientKey);
		metadata.put(clientFreshnessKey, clientFreshness);
		metadata.put(signatureKey, SignatureHandler.publicSign(Bytes.concat(Ints.toByteArray(code.value()), description.getBytes(), serializedClientKey, clientFreshness), this.privateKey));

		return status.asRuntimeException(metadata);
	}

	private synchronized int addCounter(){
		return announcementID++;
	}

	private Contract.ACK buildACKresponse(MessageHandler messageHandler, String typeSignature){

		byte[] freshness = Longs.toByteArray(messageHandler.getFreshness());

		byte[] signature = null;

		if(typeSignature.equals("publicSign")){
			signature = SignatureHandler.publicSign(freshness, this.privateKey);
		}
		if(typeSignature.equals("hmac")){
			signature = messageHandler.calculateHMAC(new byte[0], freshness);
		}

		return Contract.ACK.newBuilder().setFreshness(ByteString.copyFrom(freshness)).setSignature(ByteString.copyFrom(signature)).build();
	}

	private Contract.ReadResponse buildReadResponse(MessageHandler messageHandler, byte[] responseAnnouncements){
		byte[] responseFreshness = Longs.toByteArray(messageHandler.getFreshness());
		byte[] responseSignature = messageHandler.calculateHMAC(responseAnnouncements, responseFreshness);

		return Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(responseAnnouncements)).setFreshness(ByteString.copyFrom(responseFreshness)).setSignature(ByteString.copyFrom(responseSignature)).build();
	}

	/***********************/
	/** TESTING FUNCTIONS **/
	/***********************/

	@Override
	public void clientRegisteredState(Contract.RegisterRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());

		boolean isUserRegistered = privateBoard.containsKey(userKey);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(isUserRegistered).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postState(Contract.PostRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		char[] post = new String(request.getMessage().toByteArray()).toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		String[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		Announcement testingAnnouncement = new Announcement(post, userKey, announcements, addCounter(), null);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(false).build();

		if(this.privateBoard.get(userKey) == null){
			responseObserver.onNext(response);
			responseObserver.onCompleted();
			return;
		}
		for (Announcement announcement: this.privateBoard.get(userKey)) {
			if(announcement.equals(testingAnnouncement)){
				response = Contract.TestsResponse.newBuilder().setTestResult(true).build();
				break;
			}
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneralState(Contract.PostRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		char[] post = new String(request.getMessage().toByteArray()).toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		String[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		Announcement testingAnnouncement = new Announcement(post, userKey, announcements, addCounter(), null);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(false).build();

		for (Announcement announcement: this.generalBoard) {
			if(announcement.equals(testingAnnouncement)){
				response = Contract.TestsResponse.newBuilder().setTestResult(true).build();
			}
		}

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void cleanPosts(Empty request, StreamObserver<Empty> responseObserver) {
		this.privateBoard = new ConcurrentHashMap<>();
		this.announcementIDs = new ConcurrentHashMap<>();
		try{
			save("posts");
		}catch (DatabaseException e){
			e.getCause();
		}
		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void cleanGeneralPosts(Empty request, StreamObserver<Empty> responseObserver) {
		this.generalBoard = new ArrayList<>();
		this.announcementIDs = new ConcurrentHashMap<>();
		try{
			save("generalPosts");
		}catch (DatabaseException e){
			e.getCause();
		}
		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

}

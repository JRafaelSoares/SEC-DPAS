package pt.ulisboa.tecnico.SECDPAS;

/* these are generated by the Contract */
import SECDPAS.grpc.Contract;
import SECDPAS.grpc.DPASServiceGrpc;
import com.google.common.primitives.Bytes;
import com.google.common.primitives.Ints;
import com.google.protobuf.ByteString;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import org.apache.commons.lang3.SerializationUtils;
import javax.crypto.SecretKey;
import javax.xml.crypto.Data;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.security.PublicKey;
import java.security.SignatureException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class DPASServiceImpl extends DPASServiceGrpc.DPASServiceImplBase {

	private ConcurrentHashMap<PublicKey, ArrayList<Announcement>> privateBoard = new ConcurrentHashMap<>();
	private CopyOnWriteArrayList<Announcement> generalBoard = new CopyOnWriteArrayList<>();
	private ConcurrentHashMap<PublicKey, MessageHandler> clientSessions = new ConcurrentHashMap<>();

	private String databasePath;

	public DPASServiceImpl() throws DatabaseException{
		Path currentRelativePath = Paths.get("");
		this.databasePath = currentRelativePath.toAbsolutePath().toString() + "/src/database";
		load();
	}

	@Override
	public void setupConnection(Contract.DHRequest request, StreamObserver<Contract.DHResponse> responseObserver){
		byte[] encodedClientKey = request.getPublicKey().toByteArray();
		byte[] clientAgreement = request.getClientAgreement().toByteArray();
		byte[] clientFreshness = request.getFreshness().toByteArray();
		byte[] clientSignature = request.getSignature().toByteArray();

		PublicKey userKey = SerializationUtils.deserialize(encodedClientKey);

		// Check that the client exists
		if(!this.privateBoard.containsKey(userKey)){
			responseObserver.onError(new ServerNotRegisteredException("Client not yet registered"));
			return;
		}

		// Check that request is fresh
		MessageHandler messageHandler = clientSessions.get(userKey);

		try {
			messageHandler.verifyFreshness(clientFreshness);
		} catch (MessageNotFreshException e) {
			responseObserver.onError(new ServerRequestNotFreshException("Diffie-Hellman request not fresh"));
		}

		// Check that the signature is valid and matches the user
		if(!SignatureHandler.verifyPublicSignature(Bytes.concat(encodedClientKey, clientAgreement, clientFreshness), clientSignature, userKey)){
			responseObserver.onError(new ServerInvalidSignatureException("Request signature not valid"));
			return;
		}

		// Perform server side of the agreement and add a new message handler for the current client's session
		DiffieHellmanServer dhServer = new DiffieHellmanServer();
		byte[] serverAgreement = dhServer.execute(clientAgreement);

		SecretKey hmacKey = dhServer.getSharedHMACKey();

		messageHandler.resetSignature(hmacKey);

		byte[] freshness = messageHandler.getFreshness();

		//byte[] signature = SignatureHandler.publicSign(Bytes.concat(serverAgreement, freshness), serverKey);
		byte[] signature = new byte[256];

		Contract.DHResponse response = Contract.DHResponse.newBuilder().setServerAgreement(ByteString.copyFrom(serverAgreement)).setFreshness(ByteString.copyFrom(freshness)).setSignature(ByteString.copyFrom(signature)).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void register(Contract.RegisterRequest request, StreamObserver<Contract.ACK> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		if(this.privateBoard.get(userKey) != null){
			//TODO- Add freshness check here
			responseObserver.onError(new ServerAlreadyRegisteredException("Client is already registered"));
			return;
		}

		this.privateBoard.put(userKey, new ArrayList<>());

		// Create new messageHandler for this client
		MessageHandler messageHandler = new MessageHandler(null);
		this.clientSessions.put(userKey, messageHandler);

		byte[] freshness = messageHandler.getFreshness();
		//TODO- Create server key pair
		//byte[] signature = SignatureHandler.publicSign(freshness, serverKey);
		byte[] signature = new byte[256];

		Contract.ACK response = Contract.ACK.newBuilder().setFreshness(ByteString.copyFrom(freshness)).setSignature(ByteString.copyFrom(signature)).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void post(Contract.PostRequest request, StreamObserver<Contract.ACK> responseObserver) {

		byte[] serializedPublicKey = request.getPublicKey().toByteArray();
		byte[] message = request.getMessage().getBytes();
		byte[] serializedAnnouncements = request.getAnnouncements().toByteArray();
		byte[] freshness = request.getFreshness().toByteArray();
		byte[] signature = request.getSignature().toByteArray();


		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(serializedPublicKey);
		Announcement[] announcements = SerializationUtils.deserialize(serializedAnnouncements);

		ArrayList<Announcement> announcementList = this.privateBoard.get(userKey);

		if(announcementList == null){
			responseObserver.onError(new ServerNotRegisteredException("Client not yet registered"));
			return;
		}

		// Check if request is fresh
		MessageHandler messageHandler = clientSessions.get(userKey);

		if(!messageHandler.isInSession()){
			responseObserver.onError(new ServerNoSessionException("No Diffie-Hellman session is established"));
			return;
		}

		try {
			messageHandler.verifyMessage(Bytes.concat(serializedPublicKey, message, serializedAnnouncements), freshness, signature);
		} catch (SignatureNotValidException e) {
			responseObserver.onError(new ServerInvalidSignatureException("Request signature invalid"));
			return;
		} catch (MessageNotFreshException e) {
			responseObserver.onError(new ServerRequestNotFreshException("Request is not fresh"));
			return;
		}

		announcementList.add(new Announcement(post, userKey, announcements));

		byte[] responseFreshness = messageHandler.getFreshness();
		byte[] responseSignature = messageHandler.sign(new byte[0], responseFreshness);

		Contract.ACK response = Contract.ACK.newBuilder().setFreshness(ByteString.copyFrom(responseFreshness)).setSignature(ByteString.copyFrom(responseSignature)).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneral(Contract.PostRequest request, StreamObserver<Contract.ACK> responseObserver) {
		byte[] serializedPublicKey = request.getPublicKey().toByteArray();
		byte[] message = request.getMessage().getBytes();
		byte[] serializedAnnouncements = request.getAnnouncements().toByteArray();
		byte[] freshness = request.getFreshness().toByteArray();
		byte[] signature = request.getSignature().toByteArray();

		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(serializedPublicKey);
		Announcement[] announcements = SerializationUtils.deserialize(serializedAnnouncements);

		if(!this.privateBoard.containsKey(userKey)){
			responseObserver.onError(new ServerNotRegisteredException("Client not yet registered"));
			return;
		}

		// Check if request is fresh
		MessageHandler messageHandler = clientSessions.get(userKey);

		if(!messageHandler.isInSession()){
			responseObserver.onError(new ServerNoSessionException("No Diffie-Hellman session is established"));
			return;
		}

		try {
			messageHandler.verifyMessage(Bytes.concat(serializedPublicKey, message, serializedAnnouncements), freshness, signature);
		} catch (SignatureNotValidException e) {
			responseObserver.onError(new ServerInvalidSignatureException("Request signature invalid"));
			return;
		} catch (MessageNotFreshException e) {
			responseObserver.onError(new ServerRequestNotFreshException("Request is not fresh"));
			return;
		}

		//TODO- Announcement can be null, mby test for it? Add try catch?
		this.generalBoard.add(new Announcement(post, userKey, announcements));

		byte[] responseFreshness = messageHandler.getFreshness();
		byte[] responseSignature = messageHandler.sign(new byte[0], responseFreshness);

		Contract.ACK response = Contract.ACK.newBuilder().setFreshness(ByteString.copyFrom(responseFreshness)).setSignature(ByteString.copyFrom(responseSignature)).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void read(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		byte[] serializedPublicKey = request.getPublicKey().toByteArray();
		int numPosts = request.getNumber();
		byte[] number = Ints.toByteArray(numPosts);
		byte[] freshness = request.getFreshness().toByteArray();
		byte[] signature = request.getSignature().toByteArray();

		PublicKey userKey = SerializationUtils.deserialize(serializedPublicKey);

		ArrayList<Announcement> announcementList = this.privateBoard.get(userKey);

		if(announcementList == null){
			responseObserver.onError(new ServerNotRegisteredException("Client not yet registered"));
			return;
		}

		MessageHandler messageHandler = clientSessions.get(userKey);

		if(!messageHandler.isInSession()){
			responseObserver.onError(new ServerNoSessionException("No Diffie-Hellman session is established"));
			return;
		}

		try {
			messageHandler.verifyMessage(Bytes.concat(serializedPublicKey, number), freshness, signature);
		} catch (SignatureNotValidException e) {
			responseObserver.onError(new ServerInvalidSignatureException("Request signature invalid"));
			return;
		} catch (MessageNotFreshException e) {
			responseObserver.onError(new ServerRequestNotFreshException("Request is not fresh"));
			return;
		}

		byte[] responseAnnouncements;
		if(numPosts == 0 || numPosts > announcementList.size()){
			//deserializes the array and transforms it to gRPC
			responseAnnouncements = SerializationUtils.serialize(announcementList.toArray(new Announcement[0]));
		}
		else{
			List<Announcement> toSend =  announcementList.subList(announcementList.size() - numPosts, announcementList.size());
			Announcement[] announcements = toSend.toArray(new Announcement[0]);

			responseAnnouncements = SerializationUtils.serialize(announcements);
		}

		byte[] responseFreshness = messageHandler.getFreshness();
		byte[] responseSignature = messageHandler.sign(responseAnnouncements, responseFreshness);

		Contract.ReadResponse response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(responseAnnouncements)).setFreshness(ByteString.copyFrom(responseFreshness)).setSignature(ByteString.copyFrom(responseSignature)).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void readGeneral(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		byte[] serializedPublicKey = request.getPublicKey().toByteArray();
		int numPosts = request.getNumber();
		byte[] number = Ints.toByteArray(numPosts);
		byte[] freshness = request.getFreshness().toByteArray();
		byte[] signature = request.getSignature().toByteArray();

		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());

		if(!this.privateBoard.containsKey(userKey)){
			responseObserver.onError(new ServerNotRegisteredException("Client not yet registered"));
			return;
		}

		MessageHandler messageHandler = clientSessions.get(userKey);

		if(!messageHandler.isInSession()){
			responseObserver.onError(new ServerNoSessionException("No Diffie-Hellman session is established"));
			return;
		}

		try {
			messageHandler.verifyMessage(Bytes.concat(serializedPublicKey, number), freshness, signature);
		} catch (SignatureNotValidException e) {
			responseObserver.onError(new ServerInvalidSignatureException("Request signature invalid"));
			return;
		} catch (MessageNotFreshException e) {
			responseObserver.onError(new ServerRequestNotFreshException("Request is not fresh"));
			return;
		}

		byte[] responseAnnouncements;
		if(numPosts == 0 || numPosts > this.generalBoard.size()){
			//deserializes the array and transforms it to gRPC
			responseAnnouncements = SerializationUtils.serialize(this.generalBoard.toArray(new Announcement[0]));
		}
		else{
			//TODO - Check if subList is done correctly
			List<Announcement> toSent =  this.generalBoard.subList(this.generalBoard.size()-numPosts, this.generalBoard.size());
			responseAnnouncements = SerializationUtils.serialize(toSent.toArray(new Announcement[0]));
		}

		byte[] responseFreshness = messageHandler.getFreshness();
		byte[] responseSignature = messageHandler.sign(responseAnnouncements, responseFreshness);

		Contract.ReadResponse response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(responseAnnouncements)).setFreshness(ByteString.copyFrom(responseFreshness)).setSignature(ByteString.copyFrom(responseSignature)).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	/**********************/
	/** TESTING FUNCTION **/
	/**********************/

	@Override
	public void clientRegisteredState(Contract.RegisterRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());

		boolean isUserRegistred = privateBoard.containsKey(userKey);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(isUserRegistred).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postState(Contract.PostRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		Announcement testingAnnouncement = new Announcement(post, userKey, announcements);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(false).build();

		if(this.privateBoard.get(userKey) == null){
			responseObserver.onNext(response);
			responseObserver.onCompleted();
			return;
		}
		for (Announcement announcement: this.privateBoard.get(userKey)) {
			if(announcement.equals(testingAnnouncement)){
				response = Contract.TestsResponse.newBuilder().setTestResult(true).build();
				break;
			}
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneralState(Contract.PostRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		Announcement testingAnnouncement = new Announcement(post, userKey, announcements);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(false).build();

		for (Announcement announcement: this.generalBoard) {
			if(announcement.equals(testingAnnouncement)){
				response = Contract.TestsResponse.newBuilder().setTestResult(true).build();
			}
		}

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void cleanPosts(Empty request, StreamObserver<Empty> responseObserver) {
		this.privateBoard = new ConcurrentHashMap<>();

		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void cleanGeneralPosts(Empty request, StreamObserver<Empty> responseObserver) {
		this.generalBoard = new CopyOnWriteArrayList<>();

		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	private void save(String file) throws DatabaseException{

		try {
			FileOutputStream myWriter = new FileOutputStream(this.databasePath + "/" + file + "_try.txt");

			/* write in file */
			switch (file){
				case "posts":
					myWriter.write(SerializationUtils.serialize(privateBoard));
					break;
				case "generalPosts":
					myWriter.write(SerializationUtils.serialize(generalBoard));
					break;
			}
			myWriter.close();

			/* File successfully created, transferring to official file */
			Path src = Paths.get(this.databasePath + "/" + file + "_try.txt");
			Path dst = Paths.get(this.databasePath + "/"+ file + ".txt");

			Files.move(src, dst, StandardCopyOption.ATOMIC_MOVE);

		} catch (IOException e) {
			throw new DatabaseException("Unable to save: " + e.getMessage());
		}

	}

	private void load() throws DatabaseException{

		try {
			if(new File(this.databasePath + "/posts.txt").exists()){
				/* read from file posts */
				FileInputStream myReader = new FileInputStream(this.databasePath + "/posts.txt");
				this.privateBoard = SerializationUtils.deserialize(myReader.readAllBytes());
				myReader.close();
			}
			if(new File(this.databasePath + "/generalPosts.txt").exists()) {
				/* read from file generalPosts */
				FileInputStream myReader = new FileInputStream(this.databasePath + "/generalPosts.txt");
				this.generalBoard = SerializationUtils.deserialize(myReader.readAllBytes());
				myReader.close();
			}

		} catch (IOException e) {
			throw new DatabaseException("Unable to load: " + e.getMessage());
		}

	}

}

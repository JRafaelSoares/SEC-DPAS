package pt.ulisboa.tecnico.SECDPAS;

/* these are generated by the Contract */
import SECDPAS.grpc.Contract;
import SECDPAS.grpc.DPASServiceGrpc;
import com.google.protobuf.ByteString;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import org.apache.commons.lang3.SerializationUtils;

import javax.xml.crypto.Data;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.security.PublicKey;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class DPASServiceImpl extends DPASServiceGrpc.DPASServiceImplBase {

	private ConcurrentHashMap<PublicKey, ArrayList<Announcement>> privateBoard = new ConcurrentHashMap<>();

	private CopyOnWriteArrayList<Announcement> generalBoard = new CopyOnWriteArrayList<>();

	private String databasePath;

	public DPASServiceImpl() throws DatabaseException{
		Path currentRelativePath = Paths.get("");
		this.databasePath = currentRelativePath.toAbsolutePath().toString() + "/src/database";
		load();
	}

	@Override
	public void greeting(Contract.HelloRequest request, StreamObserver<Contract.HelloResponse> responseOberserver){
		Contract.HelloResponse response = Contract.HelloResponse.newBuilder().setGreeting("OLA").build();

		responseOberserver.onNext(response);
		responseOberserver.onCompleted();
	}

	@Override
	public void register(Contract.RegisterRequest request, StreamObserver<Empty> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		if(this.privateBoard.get(userKey) != null){
			responseObserver.onError(new ServerAlreadyRegistredException("Client is already registered"));
			return;
		}
		this.privateBoard.put(userKey, new ArrayList<>());
		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void post(Contract.PostRequest request, StreamObserver<Empty> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		ArrayList<Announcement> announcementList = this.privateBoard.get(userKey);

		if(announcementList == null){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}else{
			announcementList.add(new Announcement(post, userKey, announcements));
		}
		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneral(Contract.PostRequest request, StreamObserver<Empty> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		if(!this.privateBoard.containsKey(userKey)){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}
		//TODO- Announcement can be null, mby test for it? Add try catch?
		this.generalBoard.add(new Announcement(post, userKey, announcements));
		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void read(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		int numPosts = request.getNumber();

		ArrayList<Announcement> announcementList = this.privateBoard.get(userKey);

		if(announcementList == null){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}

		Contract.ReadResponse response;
		if(numPosts == 0 || numPosts > announcementList.size()){
			//desirializes the array and transforms it to gRPC
			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(announcementList.toArray(new Announcement[0])))).build();
		}
		else{
			List<Announcement> toSent =  announcementList.subList(announcementList.size()-numPosts, announcementList.size());
			Announcement[] announcements = toSent.toArray(new Announcement[0]);

			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(announcements))).build();
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void readGeneral(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		int numPosts = request.getNumber();

		if(!this.privateBoard.containsKey(userKey)){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}

		Contract.ReadResponse response;
		if(numPosts == 0 || numPosts > this.generalBoard.size()){
			//desirializes the array and transforms it to gRPC
			Announcement[] array = this.generalBoard.toArray(new Announcement[0]);
			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(array))).build();
		}

		else{
			//TODO - Check if subList is done correctly
			List<Announcement> toSent =  this.generalBoard.subList(this.generalBoard.size()-numPosts, this.generalBoard.size());
			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(toSent.toArray(new Announcement[0] )))).build();
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	/**********************/
	/** TESTING FUNCTION **/
	/**********************/

	@Override
	public void clientRegisteredState(Contract.RegisterRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());

		boolean isUserRegistred = privateBoard.containsKey(userKey);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(isUserRegistred).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postState(Contract.PostRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		Announcement testingAnnouncement = new Announcement(post, userKey, announcements);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(false).build();

		for (Announcement announcement: this.privateBoard.get(userKey)) {
			if(announcement.equals(testingAnnouncement)){
				response = Contract.TestsResponse.newBuilder().setTestResult(true).build();
				break;
			}
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneralState(Contract.PostRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		Announcement testingAnnouncement = new Announcement(post, userKey, announcements);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(false).build();

		for (Announcement announcement: this.generalBoard) {
			if(announcement.equals(testingAnnouncement)){
				response = Contract.TestsResponse.newBuilder().setTestResult(true).build();
			}
		}

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void cleanPosts(Empty request, StreamObserver<Empty> responseObserver) {
		this.privateBoard = new ConcurrentHashMap<>();

		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void cleanGeneralPosts(Empty request, StreamObserver<Empty> responseObserver) {
		this.generalBoard = new CopyOnWriteArrayList<>();

		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	private void save(String file) throws DatabaseException{

		try {
			FileOutputStream myWriter = new FileOutputStream(this.databasePath + "/" + file + "_try.txt");

			/* write in file */
			switch (file){
				case "posts":
					myWriter.write(SerializationUtils.serialize(privateBoard));
					break;
				case "generalPosts":
					myWriter.write(SerializationUtils.serialize(generalBoard));
					break;
			}
			myWriter.close();

			/* File successfully created, transferring to official file */
			Path src = Paths.get(this.databasePath + "/" + file + "_try.txt");
			Path dst = Paths.get(this.databasePath + "/"+ file + ".txt");

			Files.move(src, dst, StandardCopyOption.ATOMIC_MOVE);

		} catch (IOException e) {
			throw new DatabaseException("Unable to save: " + e.getMessage());
		}

	}

	private void load() throws DatabaseException{

		try {
			if(new File(this.databasePath + "/posts.txt").exists()){
				/* read from file posts */
				FileInputStream myReader = new FileInputStream(this.databasePath + "/posts.txt");
				this.privateBoard = SerializationUtils.deserialize(myReader.readAllBytes());
				myReader.close();
			}
			if(new File(this.databasePath + "/generalPosts.txt").exists()) {
				/* read from file generalPosts */
				FileInputStream myReader = new FileInputStream(this.databasePath + "/generalPosts.txt");
				this.generalBoard = SerializationUtils.deserialize(myReader.readAllBytes());
				myReader.close();
			}

			System.out.println(this.privateBoard.size() + " " + this.generalBoard.size());

		} catch (IOException e) {
			throw new DatabaseException("Unable to load: " + e.getMessage());
		}

	}

}

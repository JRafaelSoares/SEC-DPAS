package pt.ulisboa.tecnico.SECDPAS;

/* these are generated by the Contract */
import SECDPAS.grpc.Contract;
import SECDPAS.grpc.DPASServiceGrpc;
import com.google.common.primitives.Bytes;
import com.google.common.primitives.Ints;
import com.google.common.primitives.Longs;
import com.google.protobuf.ByteString;
import com.google.protobuf.Empty;
import io.grpc.*;
import io.grpc.stub.StreamObserver;
import org.apache.commons.lang3.SerializationException;
import org.apache.commons.lang3.SerializationUtils;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.security.*;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.BiConsumer;

public class DPASServiceImpl extends DPASServiceGrpc.DPASServiceImplBase {

	private String host = "localhost";
	private int port = 8080;

	private ConcurrentHashMap<PublicKey, ArrayList<Announcement>> privateBoard = new ConcurrentHashMap<>();
	private ArrayList<Announcement> generalBoard = new ArrayList<>();
	private ConcurrentHashMap<PublicKey, FreshnessHandler> clientReadFreshness = new ConcurrentHashMap<>();
	private ConcurrentHashMap<PublicKey, FreshnessHandler> clientWriteFreshness = new ConcurrentHashMap<>();

	private MessageDigest messageHasher;

	private ConcurrentHashMap<String, Announcement> announcementIDs = new ConcurrentHashMap<>();

	private AuthenticatedPerfectLink[] serverPerfectLinks;
	private PublicKey[] serverPublicKeys;
	private HashMap<RequestType, AuthenticatedDoubleEchoBroadcast> authenticatedDoubleEchoBroadcasts;

	private String databasePath;

	private PrivateKey privateKey;

	private String privateBoardId = "0";
	private String generalBoardId = "1";

	private int serverID;
	private int numServers;
	private int numFaults;
	/* for debugging change to 1 */
	private int debug = 0;

	/* Test variables */
	private ManagedChannel[] channel;

	public DPASServiceImpl(PrivateKey privateKey, int id, int faults) throws DatabaseException{
		Path currentRelativePath = Paths.get("");
		this.databasePath = currentRelativePath.toAbsolutePath().toString() + "/src/database";
		this.privateKey = privateKey;
		this.serverID = id;

		try {
			this.messageHasher = MessageDigest.getInstance("SHA-256");
		} catch (NoSuchAlgorithmException ignored) {
		}

		this.numServers = faults*3+1;
		this.numFaults = faults;

		this.authenticatedDoubleEchoBroadcasts = new HashMap<>();

		ManagedChannel[] channel = new ManagedChannel[numServers];
		this.serverPublicKeys = new PublicKey[numServers];
		DPASServiceGrpc.DPASServiceFutureStub[] stubs = new DPASServiceGrpc.DPASServiceFutureStub[numServers];

		//Stub and certificate for each server
		for(int server = 0; server < numServers; server++){
			String target = host + ":" + (port+server);
			channel[server] = ManagedChannelBuilder.forTarget(target).usePlaintext().build();
			stubs[server] = DPASServiceGrpc.newFutureStub(channel[server]);//.withDeadlineAfter(20, TimeUnit.SECONDS);

			//Get certificate
			try{
				CertificateFactory fact = CertificateFactory.getInstance("X.509");
				FileInputStream is = new FileInputStream (String.format("%s/src/main/security/certificates/certServer%d.der", currentRelativePath.toAbsolutePath().toString(), server));
				X509Certificate cer = (X509Certificate) fact.generateCertificate(is);
				this.serverPublicKeys[server] = cer.getPublicKey();
			} catch (CertificateException | FileNotFoundException e){
				System.out.println("Certificate for server " + server + " could not be loaded.");
				//throw new CertificateInvalidException(e.getMessage());
			}
		}

		this.serverPerfectLinks = new AuthenticatedPerfectLink[numServers];

		for (int i = 0; i < numServers; i++) {
			if (i == this.serverID) continue;
			this.serverPerfectLinks[i] = new AuthenticatedPerfectLink(stubs[i], 0, serverPublicKeys[i], serverPublicKeys[this.serverID], i, numServers + numFaults);
		}

		load();
	}

	//for tests
	public DPASServiceImpl(PrivateKey privateKey, int id, int faults, AuthenticatedPerfectLink[] serverPerfectLinks, PublicKey[] serverPublicKeys){
		Path currentRelativePath = Paths.get("");
		this.databasePath = currentRelativePath.toAbsolutePath().toString() + "/src/database";
		this.privateKey = privateKey;
		this.serverID = id;

		this.numServers = faults*3+1;
		this.numFaults = faults;

		this.authenticatedDoubleEchoBroadcasts = new HashMap<>();

		this.serverPublicKeys = new PublicKey[numServers];
		this.serverPerfectLinks = serverPerfectLinks;
		this.serverPublicKeys = serverPublicKeys;

		try {
			this.messageHasher = MessageDigest.getInstance("SHA-256");
		} catch (NoSuchAlgorithmException e) {
		}
	}

	//Test Constructor 2
	public DPASServiceImpl(PrivateKey privateKey, int faults){
		Path currentRelativePath = Paths.get("");
		this.databasePath = currentRelativePath.toAbsolutePath().toString() + "/src/database";
		this.privateKey = privateKey;
		this.serverID = 0;

		this.numServers = faults*3+1;
		this.numFaults = faults;

		this.authenticatedDoubleEchoBroadcasts = new HashMap<>();

		this.serverPublicKeys = new PublicKey[numServers];

		try {
			this.messageHasher = MessageDigest.getInstance("SHA-256");
		} catch (NoSuchAlgorithmException e) {
		}

		channel = new ManagedChannel[numServers];
		this.serverPublicKeys = new PublicKey[numServers];
		DPASServiceGrpc.DPASServiceFutureStub[] stubs = new DPASServiceGrpc.DPASServiceFutureStub[numServers];

		//Stub and certificate for each server
		for(int server = 0; server < numServers; server++){
			String target = host + ":" + (port+server);
			channel[server] = ManagedChannelBuilder.forTarget(target).usePlaintext().build();
			stubs[server] = DPASServiceGrpc.newFutureStub(channel[server]);//.withDeadlineAfter(20, TimeUnit.SECONDS);

			//Get certificate
			try{
				CertificateFactory fact = CertificateFactory.getInstance("X.509");
				FileInputStream is = new FileInputStream (String.format("%s/src/main/security/certificates/certServer%d.der", currentRelativePath.toAbsolutePath().toString(), server));
				X509Certificate cer = (X509Certificate) fact.generateCertificate(is);
				this.serverPublicKeys[server] = cer.getPublicKey();
			} catch (CertificateException | FileNotFoundException e){
				System.out.println("Certificate for server " + server + " could not be loaded.");
				//throw new CertificateInvalidException(e.getMessage());
			}
		}

		this.serverPerfectLinks = new AuthenticatedPerfectLink[numServers];

		for (int i = 0; i < numServers; i++) {
			if (i == this.serverID) continue;
			this.serverPerfectLinks[i] = new AuthenticatedPerfectLink(stubs[i], 0, serverPublicKeys[i], serverPublicKeys[this.serverID], i, numServers + numFaults);
		}

	}

	//For test shutdown only
	public void shutDown(){
		for (ManagedChannel channel : channel){
			channel.shutdownNow();
		}
	}

	@Override
	public void register(Contract.RegisterRequest request, StreamObserver<Contract.ACK> responseObserver) {
		if(debug != 0) System.out.println("[" + serverID + "]" + "[REGISTER] Client registering.\n");

		byte[] encodedClientKey = request.getPublicKey().toByteArray();

		/* Obtaining the Public Key of the Client */
		PublicKey userKey = verifyPublicKey(encodedClientKey, responseObserver, 0);

		if(!verifyRegisterRequest(responseObserver, request, userKey)){
			return;
		}

		RequestType<Contract.RegisterRequest> clientRequest = new RegisterRequest(request);

		AuthenticatedDoubleEchoBroadcast aDEB;

		synchronized (authenticatedDoubleEchoBroadcasts){
			aDEB = authenticatedDoubleEchoBroadcasts.get(clientRequest);

			if(aDEB == null){
				aDEB = new AuthenticatedDoubleEchoBroadcast(clientRequest, this.serverID, this.numServers, this.numFaults, serverPerfectLinks, serverPublicKeys, this.privateKey, (r, s) -> executeRegister((Contract.RegisterRequest) r.getRequest()));
				authenticatedDoubleEchoBroadcasts.put(clientRequest, aDEB);
			}
		}

		aDEB.addECHO(this.serverID);
		aDEB.broadcastEcho();

		try {
			aDEB.waitForReadys();
		} catch (InterruptedException e) {
			System.out.println(e.getMessage());
		}

		if(debug != 0) System.out.println(String.format("[" + serverID + "]" + "[REGISTER] Client %s registered", userKey));
		byte[] signature = SignatureHandler.publicSign(encodedClientKey, this.privateKey);

		responseObserver.onNext(buildRegisterResponse(encodedClientKey));
		responseObserver.onCompleted();
	}

	@Override
	public void post(Contract.PostRequest request, StreamObserver<Contract.ACK> responseObserver) {
		if(debug != 0) System.out.println("[" + serverID + "]" + "[POST] Post request " + request.getMessage() + " from client.\n");

		/* Verify request */
		String postString = verifyPostRequest(request, responseObserver);

		/* In case the request is faulty */
		if(postString == null){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "[POST] Post request was faulty.\n");
			return;
		}

		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());

		RequestType<Contract.PostRequest> clientRequest = new PostRequest(request, "PostRequest");

		AuthenticatedDoubleEchoBroadcast aDEB;

		synchronized (authenticatedDoubleEchoBroadcasts){
			aDEB = authenticatedDoubleEchoBroadcasts.get(clientRequest);

			if(aDEB == null){
				aDEB = new AuthenticatedDoubleEchoBroadcast(clientRequest, this.serverID, this.numServers, this.numFaults, serverPerfectLinks, serverPublicKeys, this.privateKey, (r, s) -> executePost((Contract.PostRequest) r.getRequest(), s));
				authenticatedDoubleEchoBroadcasts.put(clientRequest, aDEB);
			}
		}

		aDEB.addECHO(this.serverID);
		aDEB.broadcastEcho();

		try {
			aDEB.waitForReadys();
		} catch (InterruptedException e) {
			System.out.println(e.getMessage());
		}

		long writeFreshness = this.clientWriteFreshness.get(userKey).getFreshness();
		this.clientWriteFreshness.get(userKey).incrementFreshness();

		responseObserver.onNext(buildACKresponse(userKey, privateBoardId, writeFreshness));
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneral(Contract.PostRequest request, StreamObserver<Contract.ACK> responseObserver) {
		if(debug != 0) System.out.println("[" + serverID + "]" + "[POST_GENERAL] PostGeneral request from client\n");

		/* Verify request */
		String postString = verifyPostGeneralRequest(request, responseObserver);

		/* In case the request is faulty */
		if(postString == null){
			return;
		}

		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		long writeTimeStamp = request.getFreshness();

		RequestType<Contract.PostRequest> clientRequest = new PostRequest(request, "PostGeneralRequest");

		AuthenticatedDoubleEchoBroadcast aDEB;

		synchronized (authenticatedDoubleEchoBroadcasts){
			aDEB = authenticatedDoubleEchoBroadcasts.get(clientRequest);

			if(aDEB == null){
				aDEB = new AuthenticatedDoubleEchoBroadcast(clientRequest, this.serverID, this.numServers, this.numFaults, serverPerfectLinks, serverPublicKeys, this.privateKey, (r, s) -> executePostGeneral((Contract.PostRequest) r.getRequest(), s));
				authenticatedDoubleEchoBroadcasts.put(clientRequest, aDEB);
			}
		}

		aDEB.addECHO(this.serverID);
		aDEB.broadcastEcho();

		try {
			aDEB.waitForReadys();
		} catch (InterruptedException e) {
			System.out.println(e.getMessage());
		}

		responseObserver.onNext(buildACKresponse(userKey, generalBoardId, writeTimeStamp));
		responseObserver.onCompleted();
	}

	/**********************************************/
	/** AUTHENTICATED DOUBLE BROADCAST FUNCTIONS **/
	/**********************************************/

	@Override
	public void echo(Contract.EchoRequest request, StreamObserver<Contract.EchoReadyACK> responseObserver) {

		if(debug != 0) System.out.println("[" + serverID + "]" + "[ECHO] Echo request from server " + request.getServerID() + "\n");

		byte[] serializedRequest = request.getRequest().toByteArray();
		byte[] requestHash = messageHasher.digest(serializedRequest);

		RequestType clientRequest = SerializationUtils.deserialize(serializedRequest);

		BiConsumer<RequestType, HashMap<Integer, byte[]>> executor = verifyEchoOrReady(clientRequest, responseObserver, request.getServerID(), null, serializedRequest, "Echo", requestHash, request.getSignature().toByteArray());

		if(executor == null){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "[ECHO] Echo request was faulty.\n");
			return;
		}

		synchronized (authenticatedDoubleEchoBroadcasts){
			AuthenticatedDoubleEchoBroadcast aDEB = authenticatedDoubleEchoBroadcasts.get(clientRequest);

			if(aDEB == null){
				aDEB = new AuthenticatedDoubleEchoBroadcast(clientRequest, this.serverID, this.numServers, this.numFaults, serverPerfectLinks, serverPublicKeys, this.privateKey, executor);
				authenticatedDoubleEchoBroadcasts.put(clientRequest, aDEB);
			}

			aDEB.addECHO(request.getServerID());
		}

		byte[] signature = SignatureHandler.publicSign(Bytes.concat(Ints.toByteArray(this.serverID), "Echo".getBytes(), requestHash), this.privateKey);

		responseObserver.onNext(Contract.EchoReadyACK.newBuilder().setServerID(this.serverID).setType("Echo").setRequestHash(ByteString.copyFrom(requestHash)).setSignature(ByteString.copyFrom(signature)).build());
		responseObserver.onCompleted();
	}

	@Override
	public void ready(Contract.ReadyRequest request, StreamObserver<Contract.EchoReadyACK> responseObserver) {

		if(debug != 0) System.out.println("[" + serverID + "]" + "[READY] Ready request from server " + request.getServerID() + "\n");

		byte[] serializedRequest = request.getRequest().toByteArray();
		byte[] requestHash = messageHasher.digest(serializedRequest);
		byte[] announcementSignature = request.getAnnouncementSignature().toByteArray();

		RequestType clientRequest = SerializationUtils.deserialize(serializedRequest);

		BiConsumer<RequestType, HashMap<Integer, byte[]>> executor = verifyEchoOrReady(clientRequest, responseObserver, request.getServerID(), announcementSignature, serializedRequest, "Ready", requestHash, request.getSignature().toByteArray());

		if(executor == null){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "[READY] Ready request was faulty.\n");
			return;
		}

		synchronized (authenticatedDoubleEchoBroadcasts){
			AuthenticatedDoubleEchoBroadcast aDEB = authenticatedDoubleEchoBroadcasts.get(clientRequest);

			if(aDEB == null){
				aDEB = new AuthenticatedDoubleEchoBroadcast(clientRequest, this.serverID, this.numServers, this.numFaults, serverPerfectLinks, serverPublicKeys, this.privateKey, executor);
				authenticatedDoubleEchoBroadcasts.put(clientRequest, aDEB);
			}

			aDEB.addReady(request.getServerID(), announcementSignature);
		}

		byte[] signature = SignatureHandler.publicSign(Bytes.concat(Ints.toByteArray(this.serverID), "Ready".getBytes(), requestHash), this.privateKey);

		responseObserver.onNext(Contract.EchoReadyACK.newBuilder().setServerID(this.serverID).setType("Ready").setRequestHash(ByteString.copyFrom(requestHash)).setSignature(ByteString.copyFrom(signature)).build());
		responseObserver.onCompleted();
	}

	@Override
	public void read(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {

		byte[] serializedTargetPublicKey = request.getTargetPublicKey().toByteArray();
		byte[] serializedClientPublicKey = request.getClientPublicKey().toByteArray();

		int numPosts = request.getNumber();
		long freshness = request.getFreshness();

		PublicKey targetUserKey = verifyPublicKey(serializedTargetPublicKey, responseObserver, freshness);

		PublicKey clientUserKey = verifyPublicKey(serializedClientPublicKey, responseObserver, freshness);

		if(targetUserKey == null || clientUserKey == null || !verifyReadRequest(request, responseObserver, true)){
			return;
		}

		if(debug != 0) System.out.println(String.format("[" + serverID + "]" + "[READ] Read request from client %s to client board %s\n", clientUserKey, targetUserKey));

		byte[] responseAnnouncements;

		synchronized (this.privateBoard.get(targetUserKey)){

			/* Prepare announcements */
			ArrayList<Announcement> announcementList = this.privateBoard.get(targetUserKey);

			if(numPosts == 0 || numPosts > announcementList.size()){
				responseAnnouncements = SerializationUtils.serialize(announcementList.toArray(new Announcement[0]));
			}
			else{
				List<Announcement> toSend =  announcementList.subList(announcementList.size() - numPosts, announcementList.size());
				Announcement[] announcements = toSend.toArray(new Announcement[0]);

				responseAnnouncements = SerializationUtils.serialize(announcements);
			}
		}


		responseObserver.onNext(buildReadResponse(clientUserKey, responseAnnouncements, privateBoardId));
		responseObserver.onCompleted();
	}

	@Override
	public void readGeneral(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		byte[] serializedClientPublicKey = request.getClientPublicKey().toByteArray();
		int numPosts = request.getNumber();
		long freshness = request.getFreshness();
		byte[] responseAnnouncements;

		PublicKey clientUserKey = verifyPublicKey(serializedClientPublicKey, responseObserver, freshness);

		synchronized (generalBoard){

			if(clientUserKey == null || !verifyReadRequest(request, responseObserver, false)){
				return;
			}

			if(debug != 0) System.out.println(String.format("[" + serverID + "]" + "[READ GENERAL] Read request from client %s\n", clientUserKey));

			/* Prepare announcements */

			if(numPosts == 0 || numPosts > this.generalBoard.size()){
				responseAnnouncements = SerializationUtils.serialize(this.generalBoard.toArray(new Announcement[0]));
			}
			else{
				List<Announcement> toSent =  this.generalBoard.subList(this.generalBoard.size() - numPosts, this.generalBoard.size());
				responseAnnouncements = SerializationUtils.serialize(toSent.toArray(new Announcement[0]));
			}
		}

		responseObserver.onNext(buildReadResponse(clientUserKey, responseAnnouncements, generalBoardId));
		responseObserver.onCompleted();
	}

	private synchronized void save(String file) throws DatabaseException{
		try {
			FileOutputStream myWriter = new FileOutputStream(String.format("%s/%s/%s%d_try.txt", this.databasePath, file, file, this.serverID));

			/* write in file */
			switch (file) {
				case "posts":
					synchronized (privateBoard){
						myWriter.write(SerializationUtils.serialize(privateBoard));
					}
					break;
				case "generalPosts":
					synchronized (generalBoard){
						myWriter.write(SerializationUtils.serialize(generalBoard));
					}
					break;
			}
			myWriter.close();

			/* File successfully created, transferring to official file */
			Path src = Paths.get(String.format("%s/%s/%s%d_try.txt", this.databasePath, file, file, this.serverID));
			Path dst = Paths.get(String.format("%s/%s/%s%d.txt", this.databasePath, file, file, this.serverID));

			Files.move(src, dst, StandardCopyOption.ATOMIC_MOVE);
			//Saves the IDs persistently
			saveIDs();
			saveFreshness();
		} catch (IOException e) {
			throw new DatabaseException("Unable to save: " + e.getMessage());
		}

	}

	private void saveIDs() throws DatabaseException{
		try {
			FileOutputStream myWriter = new FileOutputStream(String.format("%s/announcementsID/announcementsID%d_try.txt", this.databasePath, this.serverID));
			myWriter.write(SerializationUtils.serialize(this.announcementIDs));
			myWriter.close();

			/* File successfully created, transferring to official file */
			Path src = Paths.get(String.format("%s/announcementsID/announcementsID%d_try.txt", this.databasePath, this.serverID));
			Path dst = Paths.get(String.format("%s/announcementsID/announcementsID%d.txt", this.databasePath, this.serverID));

			Files.move(src, dst, StandardCopyOption.ATOMIC_MOVE);

		} catch (IOException e) {
			throw new DatabaseException("Unable to save: " + e.getMessage());
		}

	}

	private void saveFreshness() throws DatabaseException{
		try {
			FileOutputStream myWriter = new FileOutputStream(String.format("%s/clientReadFreshness/clientReadFreshness%d_try.txt", this.databasePath, this.serverID));
			myWriter.write(SerializationUtils.serialize(this.clientReadFreshness));
			myWriter.close();

			/* File successfully created, transferring to official file */
			Path src = Paths.get(String.format("%s/clientReadFreshness/clientReadFreshness%d_try.txt", this.databasePath, this.serverID));
			Path dst = Paths.get(String.format("%s/clientReadFreshness/clientReadFreshness%d.txt", this.databasePath, this.serverID));

			Files.move(src, dst, StandardCopyOption.ATOMIC_MOVE);

			myWriter = new FileOutputStream(String.format("%s/clientWriteFreshness/clientWriteFreshness%d_try.txt", this.databasePath, this.serverID));
			myWriter.write(SerializationUtils.serialize(this.clientWriteFreshness));
			myWriter.close();

			/* File successfully created, transferring to official file */
			src = Paths.get(String.format("%s/clientWriteFreshness/clientWriteFreshness%d_try.txt", this.databasePath, this.serverID));
			dst = Paths.get(String.format("%s/clientWriteFreshness/clientWriteFreshness%d.txt", this.databasePath, this.serverID));

			Files.move(src, dst, StandardCopyOption.ATOMIC_MOVE);

		} catch (IOException e) {
			throw new DatabaseException("Unable to save: " + e.getMessage());
		}

	}

	private synchronized void load() throws DatabaseException{
		try {
			if (new File(String.format("%s/posts/posts%d.txt", this.databasePath, this.serverID)).exists()) {
				/* read from file posts */
				FileInputStream myReader = new FileInputStream(String.format("%s/posts/posts%d.txt", this.databasePath, this.serverID));
				this.privateBoard = SerializationUtils.deserialize(myReader.readAllBytes());
				for(PublicKey key: this.privateBoard.keySet()){
					this.clientReadFreshness.put(key, new FreshnessHandler());
					this.clientWriteFreshness.put(key, new FreshnessHandler());
				}
				myReader.close();
			}
			if (new File(String.format("%s/generalPosts/generalPosts%d.txt", this.databasePath, this.serverID)).exists()) {
				/* read from file generalPosts */
				FileInputStream myReader = new FileInputStream(String.format("%s/generalPosts/generalPosts%d.txt", this.databasePath, this.serverID));
				this.generalBoard = SerializationUtils.deserialize(myReader.readAllBytes());
				myReader.close();
			}
			if(new File(String.format("%s/announcementsID/announcementsID%d.txt", this.databasePath, this.serverID)).exists()) {
				/* read from file generalPosts */
				FileInputStream myReader = new FileInputStream(String.format("%s/announcementsID/announcementsID%d.txt", this.databasePath, this.serverID));
				this.announcementIDs = SerializationUtils.deserialize(myReader.readAllBytes());
				myReader.close();
			}
			if(new File(String.format("%s/clientReadFreshness/clientReadFreshness%d.txt", this.databasePath, this.serverID)).exists()) {
				/* read from file generalPosts */
				FileInputStream myReader = new FileInputStream(String.format("%s/clientReadFreshness/clientReadFreshness%d.txt", this.databasePath, this.serverID));
				this.clientReadFreshness = SerializationUtils.deserialize(myReader.readAllBytes());
				myReader.close();
			}
			if(new File(String.format("%s/clientWriteFreshness/clientWriteFreshness%d.txt", this.databasePath, this.serverID)).exists()) {
				/* read from file generalPosts */
				FileInputStream myReader = new FileInputStream(String.format("%s/clientWriteFreshness/clientWriteFreshness%d.txt", this.databasePath, this.serverID));
				this.clientWriteFreshness = SerializationUtils.deserialize(myReader.readAllBytes());
				myReader.close();
			}

		} catch (IOException e) {
			throw new DatabaseException("Unable to load: " + e.getMessage());
		}
	}

	/************************/
	/** EXECUTOR FUNCTIONS **/
	/************************/

	private void executeRegister(Contract.RegisterRequest request){
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());

		/* Registering client */
		this.clientReadFreshness.put(userKey, new FreshnessHandler());
		this.clientWriteFreshness.put(userKey, new FreshnessHandler());
		this.privateBoard.put(userKey, new ArrayList<>());

		/* Saving posts */
		try{
			save("posts");
		} catch (DatabaseException e){
			System.out.println("[REGISTER] ERROR - DatabaseException -  " + e.getMessage() + "\n");
		}
	}

	private void executePost(Contract.PostRequest request, HashMap<Integer, byte[]> signatures){
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		String[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());
		long writeTimeStamp = request.getFreshness();
		String postString = request.getMessage();

		/* create post */
		char[] post = postString.toCharArray();
		String announcementID;
		Announcement announcement;
		synchronized (this.privateBoard.get(userKey)) {

			ArrayList<Announcement> announcementList = this.privateBoard.get(userKey);

			announcementID = getAnnouncementId(userKey, request.getFreshness(), privateBoardId);
			announcement = new Announcement(post, userKey, announcements, announcementID, request.getMessageSignature().toByteArray(), writeTimeStamp, privateBoardId, signatures);

			announcementList.add(announcement);
		}

		this.announcementIDs.put(announcementID, announcement);
		if(debug != 0) System.out.println(String.format("[POST] Post %s with announcementID %s from Client %s posted", new String(post), announcementID, userKey));

		/* Save posts */
		try{
			save("posts");
		} catch (DatabaseException e){
			e.getCause();
		}
	}

	private void executePostGeneral(Contract.PostRequest request, HashMap<Integer, byte[]> signatures){
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		String[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());
		long writeTimeStamp = request.getFreshness();
		String postString = request.getMessage();

		/* create post */
		char[] post = postString.toCharArray();

		String announcementID = getAnnouncementId(userKey, request.getFreshness(), generalBoardId);
		if(announcementIDs.containsKey(announcementID)){
			if (debug != 0) System.out.println("[POST-GENERAL] Repeated announcement ID");
			return;
		}
		Announcement announcement = new Announcement(post, userKey, announcements, announcementID, request.getMessageSignature().toByteArray(), writeTimeStamp, generalBoardId, signatures);

		synchronized(generalBoard) {
			if(this.generalBoard.isEmpty()){
				this.generalBoard.add(announcement);
			}else{
				for(int i = generalBoard.size()-1; i >= 0; i--){

					if(generalBoard.get(i).getFreshness() < announcement.getFreshness()){
						this.generalBoard.add(announcement);
						break;
					}

					if(generalBoard.get(i).getFreshness() == announcement.getFreshness()){

						String publicKey1 = Base64.getEncoder().encodeToString(generalBoard.get(i).getPublicKey().getEncoded());
						String publicKey2 = Base64.getEncoder().encodeToString(announcement.getPublicKey().getEncoded());

						if(publicKey1.compareTo(publicKey2) > 0){
							this.generalBoard.add(i, announcement);
						}else{
							this.generalBoard.add(i+1, announcement);
						}
						break;
					}
				}
			}
		}

		this.announcementIDs.put(announcementID, announcement);

		if(debug != 0) System.out.println(String.format("[POST_GENERAL] Post %s with announcementID %s from Client %s posted", new String(post), announcementID, userKey));

		/* Save posts */
		try{
			save("generalPosts");
		} catch (DatabaseException e){
			e.getCause();
		}

	}

	/************************/
	/** AUXILIAR FUNCTIONS **/
	/************************/

	private String getAnnouncementId(PublicKey user, long freshness, String id){
		return Base64.getEncoder().encodeToString(user.getEncoded()) + freshness + id;
	}

	private PublicKey verifyPublicKey(byte[] serializedPublicKey, StreamObserver<?> responseObserver, long clientFreshness){
		try{
			return SerializationUtils.deserialize(serializedPublicKey);
		}catch(SerializationException e){
			responseObserver.onError(buildException(Status.Code.INVALID_ARGUMENT, "PublicKey", serializedPublicKey, clientFreshness));
			return null;
		}
	}

	private boolean verifyClientIsRegistered(PublicKey userKey, StreamObserver<?> responseObserver, byte[] serializedClientKey, long clientFreshness) {
		if(!this.privateBoard.containsKey(userKey)){
			if(debug != 0) System.out.println("\t ERROR: PERMISSION_DENIED - ClientNotRegistered.\n");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientNotRegistered", serializedClientKey, clientFreshness));
			return false;
		}
		return true;
	}

	/************************/
	/***  REGISTER CHECKS ***/
	/************************/

	private boolean verifyRegisterRequest(StreamObserver<Contract.ACK> streamObserver, Contract.RegisterRequest request, PublicKey userKey){
		return userKey != null &&
				verifyRegisterSignature(streamObserver, userKey, request.getPublicKey().toByteArray(), request.getSignature().toByteArray()) &&
				verifyClientIsNotRegistered(userKey, streamObserver, SerializationUtils.serialize(userKey));
	}

	private boolean verifyRegisterRequest(StreamObserver<Contract.EchoReadyACK> streamObserver, Contract.RegisterRequest request, PublicKey userKey, String type, byte[] requestHash){
		return userKey != null &&
				verifyRegisterSignature(streamObserver, userKey, request.getPublicKey().toByteArray(), request.getSignature().toByteArray()) &&
				verifyClientIsNotRegistered(userKey, streamObserver, type, requestHash);
	}

	private boolean verifyRegisterSignature(StreamObserver<?> responseObserver, PublicKey userKey, byte[] message, byte[] clientSignature){
		if(!SignatureHandler.verifyPublicSignature(message, clientSignature, userKey)){
			if(debug != 0) System.out.println("\t ERROR: PERMISSION_DENIED - ClientIntegrityViolation.\n");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientIntegrityViolation", SerializationUtils.serialize(userKey), -1));
			return false;
		}
		return true;
	}

	private boolean verifyClientIsNotRegistered(PublicKey userKey, StreamObserver<Contract.ACK> responseObserver, byte[] serializedClientKey){
		if(this.privateBoard.get(userKey) != null){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "[REGISTER] Client already registered, sending ACK.");
			responseObserver.onNext(buildRegisterResponse(serializedClientKey));
			responseObserver.onCompleted();
			return false;
		}
		return true;
	}

	private boolean verifyClientIsNotRegistered(PublicKey userKey, StreamObserver<Contract.EchoReadyACK> responseObserver, String type, byte[] requestHash){
		if(this.privateBoard.get(userKey) != null){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "[REGISTER] Client already registered, sending ACK.");
			responseObserver.onNext(buildEchoReadyACKresponse(type, requestHash));
			responseObserver.onCompleted();
			return false;
		}
		return true;
	}

	/************************/
	/*****  POST CHECKS *****/
	/************************/

	private String verifyPostRequest(Contract.PostRequest request, StreamObserver<Contract.ACK> responseObserver){

		//PostRequest Arguments
		byte[] serializedPublicKey = request.getPublicKey().toByteArray();
		String post = request.getMessage();
		byte[] serializedAnnouncements = request.getAnnouncements().toByteArray();
		long freshness = request.getFreshness();
		String board = request.getBoard();

		byte[] packet = Bytes.concat(serializedPublicKey, post.getBytes(), serializedAnnouncements, Longs.toByteArray(freshness), board.getBytes());

		byte[] messageSignature = request.getMessageSignature().toByteArray();

		/* Obtaining the Public Key of the Client */
		PublicKey userKey = verifyPublicKey(serializedPublicKey, responseObserver, freshness);

		/* Verify message freshness and integrity-signature. References exists.*/
		if(userKey == null || !verifyPostMessage(responseObserver, packet, messageSignature, userKey, freshness)){
			return null;
		}

		String[] announcements = verifyAnnouncements(serializedAnnouncements, responseObserver, serializedPublicKey, freshness);

		if(announcements == null || !verifyReferences(announcements, responseObserver, serializedPublicKey, freshness)){
			return null;
		}

		return post;
	}

	private String verifyPostRequest(Contract.PostRequest request, StreamObserver<Contract.EchoReadyACK> responseObserver, String type, byte[] requestHash){

		//PostRequest Arguments
		byte[] serializedPublicKey = request.getPublicKey().toByteArray();
		String post = request.getMessage();
		byte[] serializedAnnouncements = request.getAnnouncements().toByteArray();
		long freshness = request.getFreshness();
		String board = request.getBoard();

		byte[] packet = Bytes.concat(serializedPublicKey, post.getBytes(), serializedAnnouncements, Longs.toByteArray(freshness), board.getBytes());

		byte[] messageSignature = request.getMessageSignature().toByteArray();

		/* Obtaining the Public Key of the Client */
		PublicKey userKey = verifyPublicKey(serializedPublicKey, responseObserver, freshness);

		/* Verify message freshness and integrity-signature. References exists.*/
		if(userKey == null || !verifyPostMessage(responseObserver, packet, messageSignature, userKey, freshness, type, requestHash)){
			return null;
		}

		String[] announcements = verifyAnnouncements(serializedAnnouncements, responseObserver, serializedPublicKey, freshness);

		if(announcements == null || !verifyReferences(announcements, responseObserver, serializedPublicKey, freshness)){
			return null;
		}

		return post;
	}

    private boolean verifyPostMessage(StreamObserver<Contract.ACK> responseObserver, byte[] supposedMessage, byte[] signature, PublicKey userKey, long clientFreshness){
		return verifySignature(responseObserver, supposedMessage, signature, userKey, clientFreshness) &&
				verifyClientIsRegistered(userKey, responseObserver, SerializationUtils.serialize(userKey), clientFreshness) &&
				verifyPostFreshness(responseObserver, userKey, clientFreshness) &&
				verifyWriteFreshness(responseObserver, userKey, clientFreshness);
	}

	private boolean verifyPostMessage(StreamObserver<Contract.EchoReadyACK> responseObserver, byte[] supposedMessage, byte[] signature, PublicKey userKey, long clientFreshness, String type, byte[] requestHash){
		return verifySignature(responseObserver, supposedMessage, signature, userKey, clientFreshness) &&
				verifyClientIsRegistered(userKey, responseObserver, SerializationUtils.serialize(userKey), clientFreshness) &&
				verifyPostFreshness(responseObserver, userKey, clientFreshness, type, requestHash) &&
				verifyWriteFreshness(responseObserver, userKey, clientFreshness);
	}

    /********************************/
    /*****  POST GENERAL CHECKS *****/
    /********************************/
    private String verifyPostGeneralRequest(Contract.PostRequest request, StreamObserver<Contract.ACK> responseObserver){

        //PostRequest Arguments
        byte[] serializedPublicKey = request.getPublicKey().toByteArray();
        String post = request.getMessage();
        byte[] serializedAnnouncements = request.getAnnouncements().toByteArray();
        long freshness = request.getFreshness();
        String board = request.getBoard();

        byte[] packet = Bytes.concat(serializedPublicKey, post.getBytes(), serializedAnnouncements, Longs.toByteArray(freshness), board.getBytes());

        byte[] messageSignature = request.getMessageSignature().toByteArray();

        /* Obtaining the Public Key of the Client */
        PublicKey userKey = verifyPublicKey(serializedPublicKey, responseObserver, freshness);

		synchronized (generalBoard) {

			/* Verify message freshness and integrity-signature. References exists.*/
			if (userKey == null || !verifyPostGeneralMessage(responseObserver, packet, messageSignature, userKey, freshness)) {
				if(debug != 0) System.out.println("[" + serverID + "]" + "[POST-GENERAL] Check Failed");
				return null;
			}
		}

        String[] announcements = verifyAnnouncements(serializedAnnouncements, responseObserver, serializedPublicKey, freshness);

        if(announcements == null || !verifyReferences(announcements, responseObserver, serializedPublicKey, freshness)){
            return null;
        }

        return post;
    }

	private String verifyPostGeneralRequest(Contract.PostRequest request, StreamObserver<Contract.EchoReadyACK> responseObserver, String type, byte[] requestHash){

		//PostRequest Arguments
		byte[] serializedPublicKey = request.getPublicKey().toByteArray();
		String post = request.getMessage();
		byte[] serializedAnnouncements = request.getAnnouncements().toByteArray();
		long freshness = request.getFreshness();
		String board = request.getBoard();

		byte[] packet = Bytes.concat(serializedPublicKey, post.getBytes(), serializedAnnouncements, Longs.toByteArray(freshness), board.getBytes());

		byte[] messageSignature = request.getMessageSignature().toByteArray();

		/* Obtaining the Public Key of the Client */
		PublicKey userKey = verifyPublicKey(serializedPublicKey, responseObserver, freshness);
		synchronized (generalBoard) {
			/* Verify message freshness and integrity-signature. References exists.*/
			if (userKey == null || !verifyPostGeneralMessage(responseObserver, packet, messageSignature, userKey, freshness, type, requestHash)) {
				if(debug != 0) System.out.println("[" + serverID + "]" + "[POST-GENERAL] Check Failed");
				return null;
			}
		}

		String[] announcements = verifyAnnouncements(serializedAnnouncements, responseObserver, serializedPublicKey, freshness);

		if(announcements == null || !verifyReferences(announcements, responseObserver, serializedPublicKey, freshness)){
			return null;
		}

		return post;
	}

	private boolean verifyPostGeneralMessage(StreamObserver<Contract.ACK> responseObserver, byte[] supposedMessage, byte[] signature, PublicKey userKey, long clientFreshness){
        return verifySignature(responseObserver, supposedMessage, signature, userKey, clientFreshness) &&
                verifyClientIsRegistered(userKey, responseObserver, SerializationUtils.serialize(userKey), clientFreshness) &&
                verifyWriteGeneralFreshness(responseObserver, userKey, clientFreshness);
    }

	private boolean verifyPostGeneralMessage(StreamObserver<Contract.EchoReadyACK> responseObserver, byte[] supposedMessage, byte[] signature, PublicKey userKey, long clientFreshness, String type, byte[] requestHash){
		return verifySignature(responseObserver, supposedMessage, signature, userKey, clientFreshness) &&
				verifyClientIsRegistered(userKey, responseObserver, SerializationUtils.serialize(userKey), clientFreshness) &&
				verifyWriteGeneralFreshness(responseObserver, userKey, clientFreshness, type, requestHash);
	}

    private boolean verifyWriteGeneralFreshness(StreamObserver<Contract.ACK> responseObserver, PublicKey userKey, long clientFreshness){
    	//Checks if freshness is lower, if there are no posts from him with that value.
		if(this.generalBoard.size() == 0){
			return true;
		}
		long highestFreshness = this.generalBoard.get(this.generalBoard.size()-1).getFreshness();

		if(clientFreshness <= highestFreshness){
			if(checkPostWithSameFreshness(userKey, clientFreshness)){
				return true;
			}
			else{
				if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "[POST_GENERAL] Already seen post, returning ACK");
				responseObserver.onNext(buildACKresponse(userKey, generalBoardId, clientFreshness));
				responseObserver.onCompleted();
				return false;
			}

		}

		else if(clientFreshness != highestFreshness+1){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "ERROR: PERMISSION_DENIED - ClientRequestNotFresh.");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientRequestNotFresh", SerializationUtils.serialize(userKey), clientFreshness));
			return false;
		}
		return true;
    }

	private boolean verifyWriteGeneralFreshness(StreamObserver<Contract.EchoReadyACK> responseObserver, PublicKey userKey, long clientFreshness, String type, byte[] requestHash){
		if(this.generalBoard.size() == 0){
			return true;
		}

		long highestFreshness = this.generalBoard.get(this.generalBoard.size()-1).getFreshness();

		if(clientFreshness <= highestFreshness){
			if(checkPostWithSameFreshness(userKey, clientFreshness)){
				return true;
			}
			else{
				if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "[POST_GENERAL] Already seen post, returning ACK");
				responseObserver.onNext(buildEchoReadyACKresponse(type, requestHash));
				responseObserver.onCompleted();
				return false;
			}

		}

		else if( clientFreshness != highestFreshness+1){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "ERROR: PERMISSION_DENIED - ClientRequestNotFresh.");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientRequestNotFresh", SerializationUtils.serialize(userKey), clientFreshness));
			return false;
		}
		return true;
	}

	private boolean checkPostWithSameFreshness(PublicKey client, long writeFreshness){
		for(int i = this.generalBoard.size()-1; i >= 0; i--){
			Announcement post = this.generalBoard.get(i);
			if(post.getFreshness() < writeFreshness){
				return true;
			}
			else if(post.getFreshness() == writeFreshness && post.getPublicKey().equals(client)){
				return false;
			}
		}
		//Case the board is empty
		return true;
	}

	private boolean verifyPostFreshness(StreamObserver<Contract.ACK> responseObserver, PublicKey userKey, long clientFreshness){
		if(this.clientWriteFreshness.get(userKey).verifyPostFreshness(clientFreshness)){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "[POST] Already seen post, returning ACK");
			responseObserver.onNext(buildACKresponse(userKey, privateBoardId, clientFreshness));
			responseObserver.onCompleted();
			return false;
		}
		return true;
	}

	private boolean verifyPostFreshness(StreamObserver<Contract.EchoReadyACK> responseObserver, PublicKey userKey, long clientFreshness, String type, byte[] requestHash){
		if(this.clientWriteFreshness.get(userKey).verifyPostFreshness(clientFreshness)){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "[POST] Already seen post, returning ACK");
			responseObserver.onNext(buildEchoReadyACKresponse(type, requestHash));
			responseObserver.onCompleted();
			return false;
		}
		return true;
	}

	private String[] verifyAnnouncements(byte[] serializedAnnouncements, StreamObserver<?> responseObserver, byte[] serializedClientKey, long clientFreshness){
		try{
			return SerializationUtils.deserialize(serializedAnnouncements);
		} catch(SerializationException e){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "ERROR: PERMISSION_DENIED - Unable to deserialize announcement.");

			responseObserver.onError(buildException(Status.Code.INVALID_ARGUMENT, "PublicKey", serializedClientKey, clientFreshness));
			return null;
		}
	}

	private boolean verifyReferences(String[] references, StreamObserver<?> responseObserver, byte[] serializedClientKey, long clientFreshness){
		for(String reference: references){
			if(!announcementIDs.containsKey(reference)){
				if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "ERROR: PERMISSION_DENIED - Invalid References.");
				responseObserver.onError(buildException(Status.Code.INVALID_ARGUMENT, "NonExistentAnnouncementReference", serializedClientKey, clientFreshness));
				return false;
			}
		}
		return true;
	}

	private boolean verifyWriteFreshness(StreamObserver<?> responseObserver, PublicKey userKey, long clientFreshness){
		if(!this.clientWriteFreshness.get(userKey).verifyFreshness(clientFreshness)){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "ERROR: PERMISSION_DENIED - ClientRequestNotFresh.");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientRequestNotFresh", SerializationUtils.serialize(userKey), clientFreshness));
			return false;
		}
		return true;
	}

	private boolean verifyReadFreshness(StreamObserver<?> responseObserver, PublicKey userKey, long clientFreshness){
		if(!this.clientReadFreshness.get(userKey).verifyFreshness(clientFreshness)){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "ERROR: PERMISSION_DENIED - ClientRequestNotFresh.");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientRequestNotFresh", SerializationUtils.serialize(userKey), clientFreshness));
			return false;
		}
		return true;
	}

	private boolean verifySignature(StreamObserver<?> responseObserver, byte[] supposedMessage, byte[] signature, PublicKey userKey, long clientFreshness){
		if(!SignatureHandler.verifyPublicSignature(supposedMessage, signature, userKey)){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "ERROR: PERMISSION_DENIED - ClientIntegrityViolation.");
			responseObserver.onError(buildException(Status.Code.PERMISSION_DENIED, "ClientIntegrityViolation", SerializationUtils.serialize(userKey), clientFreshness));
			return false;
		}
		return true;
	}


	/************************/
	/*****  READ CHECKS *****/
	/************************/

	private boolean verifyReadRequest(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver, boolean readType){
		byte[] serializedTargetPublicKey = request.getTargetPublicKey().toByteArray();
		byte[] serializedClientPublicKey = request.getClientPublicKey().toByteArray();

		int numPosts = request.getNumber();
		byte[] number = Ints.toByteArray(numPosts);
		long freshness = request.getFreshness();

		byte[] packet = Bytes.concat(serializedTargetPublicKey, serializedClientPublicKey, number, Longs.toByteArray(freshness));

		byte[] signature = request.getSignature().toByteArray();

		PublicKey clientUserKey = verifyPublicKey(serializedClientPublicKey, responseObserver, freshness);

		boolean readCheck = clientUserKey != null && verifyMessage(responseObserver, packet, signature, clientUserKey, freshness);
		boolean readGeneralCheck = true;
		if(readType){
			PublicKey targetUserKey = verifyPublicKey(serializedTargetPublicKey, responseObserver, freshness);

			readGeneralCheck = targetUserKey != null && verifyClientIsRegistered(targetUserKey, responseObserver, serializedClientPublicKey, freshness);
		}

		return readCheck && readGeneralCheck;
	}

	private boolean verifyMessage(StreamObserver<?> responseObserver, byte[] supposedMessage, byte[] signature, PublicKey userKey, long clientFreshness){
		return verifySignature(responseObserver, supposedMessage, signature, userKey, clientFreshness) &&
				verifyClientIsRegistered(userKey, responseObserver, SerializationUtils.serialize(userKey), clientFreshness) &&
				verifyReadFreshness(responseObserver, userKey, clientFreshness);
	}

	private StatusRuntimeException buildException(Status.Code code, String description, byte[] serializedClientKey, long clientFreshness){
		Status status = Status.fromCode(code).withDescription(description);

		Metadata metadata = new Metadata();

		Metadata.Key<byte[]> clientKey = Metadata.Key.of("clientKey-bin", Metadata.BINARY_BYTE_MARSHALLER);
		Metadata.Key<byte[]> clientFreshnessKey = Metadata.Key.of("clientFreshness-bin", Metadata.BINARY_BYTE_MARSHALLER);
		Metadata.Key<byte[]> signatureKey = Metadata.Key.of("signature-bin", Metadata.BINARY_BYTE_MARSHALLER);

		metadata.put(clientKey, serializedClientKey);
		metadata.put(clientFreshnessKey, Longs.toByteArray(clientFreshness));
		metadata.put(signatureKey, SignatureHandler.publicSign(Bytes.concat(Ints.toByteArray(code.value()), description.getBytes(), serializedClientKey, Longs.toByteArray(clientFreshness)), this.privateKey));

		return status.asRuntimeException(metadata);
	}


	/************************/
	/*****  ECHO CHECKS *****/
	/************************/

	private BiConsumer<RequestType, HashMap<Integer, byte[]>> verifyEchoOrReady(RequestType<?> clientRequest, StreamObserver<Contract.EchoReadyACK> responseObserver, int serverID, byte[] announcementSignature, byte[] serializedClientRequest, String type, byte[] requestHash, byte[] signature){
		byte[] message;

		if(type.equals("Echo")){
			message = Bytes.concat(Ints.toByteArray(serverID), serializedClientRequest);
		}
		else{
			message = Bytes.concat(Ints.toByteArray(serverID), announcementSignature, serializedClientRequest);
		}

		if(serverID < 0 || serverID >= this.numServers || !SignatureHandler.verifyPublicSignature(message, signature, this.serverPublicKeys[serverID])){
			if(debug != 0) System.out.println("\t" + "[" + serverID + "]" + "[ECHO_OR_READY] Signature was invalid.");
			responseObserver.onError(buildException(Status.Code.UNAUTHENTICATED, "Echo request signature invalid", new byte[0], 0));
			return null;
		}

		BiConsumer<RequestType, HashMap<Integer, byte[]>> executor;

		switch(clientRequest.getId()){
			case "RegisterRequest":
				Contract.RegisterRequest registerRequest = (Contract.RegisterRequest)clientRequest.getRequest();

				/* Obtaining the Public Key of the Client */
				PublicKey userKey = verifyPublicKey(registerRequest.getPublicKey().toByteArray(), responseObserver, 0);
				if(!verifyRegisterRequest(responseObserver, registerRequest, userKey, type, requestHash)){
					if(debug != 0) System.out.println("[" + this.serverID + "]" + " Register request from " + serverID + " was invalid");
					return null;
				}

				if(debug != 0) System.out.println("\t" + "[" + this.serverID + "]" + "[ECHO_OR_READY][REGISTER] Client " + registerRequest.getPublicKey().toByteArray()[442] + "\n");

				executor = (request, signatures) -> executeRegister((Contract.RegisterRequest) request.getRequest());
				break;
			case "PostRequest":
				Contract.PostRequest postRequest = (Contract.PostRequest) clientRequest.getRequest();

				if(debug != 0) System.out.println("\t" + "[" + this.serverID + "]" + "[ECHO_OR_READY][POST] Client " + postRequest.getPublicKey().toByteArray()[442] + " Message: " + postRequest.getMessage() + "\n");

				if(type.equals("Ready") && !SignatureHandler.verifyPublicSignature(Bytes.concat(postRequest.getPublicKey().toByteArray(), postRequest.getMessage().getBytes(), postRequest.getAnnouncements().toByteArray(), Longs.toByteArray(postRequest.getFreshness()), postRequest.getBoard().getBytes()), announcementSignature, serverPublicKeys[serverID])){
					if(debug != 0) System.out.println("\t" + "[" + this.serverID + "]" + "[ECHO_OR_READY] Announcement signature was invalid.");
					return null;
				}

				if(verifyPostRequest(postRequest, responseObserver, type, requestHash) == null){
					return null;
				}

				executor = (request, signatures) -> executePost((Contract.PostRequest) request.getRequest(), signatures);
				break;
			case "PostGeneralRequest":
				Contract.PostRequest postGeneralRequest = (Contract.PostRequest) clientRequest.getRequest();

				if(debug != 0) System.out.println("\t" + "[" + this.serverID + "]" + "[ECHO_OR_READY][POST_GENERAL] Client " + postGeneralRequest.getPublicKey().toByteArray()[442] + " Message: " + postGeneralRequest.getMessage() + "\n");

				if(type.equals("Ready") && !SignatureHandler.verifyPublicSignature(Bytes.concat(postGeneralRequest.getPublicKey().toByteArray(), postGeneralRequest.getMessage().getBytes(), postGeneralRequest.getAnnouncements().toByteArray(), Longs.toByteArray(postGeneralRequest.getFreshness()), postGeneralRequest.getBoard().getBytes()), announcementSignature, serverPublicKeys[serverID])){
					if(debug != 0) System.out.println("\t" + "[ECHO_OR_READY] Announcement signature was invalid.");
					return null;
				}

				if(verifyPostGeneralRequest(postGeneralRequest, responseObserver, type, requestHash) == null){
					return null;
				}

				executor = (request, signatures) -> executePostGeneral((Contract.PostRequest) request.getRequest(), signatures);
				break;
			default:
				return null;
		}

		return executor;
	}


	/******************************/
	/*****  RESPONSE BUILDERS *****/
	/******************************/
	public Contract.ACK buildRegisterResponse(byte[] publicKey){
		byte[] signature = SignatureHandler.publicSign(publicKey, this.privateKey);
		return Contract.ACK.newBuilder().setPublicKey(ByteString.copyFrom(publicKey)).setSignature(ByteString.copyFrom(signature)).build();
	}

	private Contract.ACK buildACKresponse(PublicKey userKey, String boardType, long freshness){
		byte[] publicKey = SerializationUtils.serialize(userKey);

		byte[] signature = SignatureHandler.publicSign(Bytes.concat(publicKey, Longs.toByteArray(freshness), boardType.getBytes()), this.privateKey);

		return Contract.ACK.newBuilder().setPublicKey(ByteString.copyFrom(publicKey)).setFreshness(freshness).setSignature(ByteString.copyFrom(signature)).build();
	}

	private Contract.EchoReadyACK buildEchoReadyACKresponse(String type, byte[] requestHash){
		byte[] signature = SignatureHandler.publicSign(Bytes.concat(Ints.toByteArray(this.serverID), type.getBytes(), requestHash), this.privateKey);
		return Contract.EchoReadyACK.newBuilder().setServerID(this.serverID).setType(type).setRequestHash(ByteString.copyFrom(requestHash)).setSignature(ByteString.copyFrom(signature)).build();
	}

	private Contract.ReadResponse buildReadResponse(PublicKey clientKey, byte[] responseAnnouncements, String board){
		long responseFreshness = clientReadFreshness.get(clientKey).getFreshness();
		this.clientReadFreshness.get(clientKey).incrementFreshness();
		byte[] publicKey = SerializationUtils.serialize(clientKey);

		byte[] responseSignature = SignatureHandler.publicSign(Bytes.concat(publicKey, responseAnnouncements, Longs.toByteArray(responseFreshness), board.getBytes()), this.privateKey);

		return Contract.ReadResponse.newBuilder().setPublicKey(ByteString.copyFrom(publicKey)).setAnnouncements(ByteString.copyFrom(responseAnnouncements)).setFreshness(responseFreshness).setSignature(ByteString.copyFrom(responseSignature)).build();
	}

	/***********************/
	/** TESTING FUNCTIONS **/
	/***********************/

	@Override
	public void clientRegisteredState(Contract.RegisterRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());

		boolean isUserRegistered = privateBoard.containsKey(userKey);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(isUserRegistered).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postState(Contract.PostRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		String[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());
		long writeTimeStamp = request.getFreshness();


		String announcementID = getAnnouncementId(userKey, request.getFreshness(), privateBoardId);
		Announcement testingAnnouncement = new Announcement(post, userKey, announcements, announcementID, null,  writeTimeStamp, privateBoardId, new HashMap<>());

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(false).build();

		if(this.privateBoard.get(userKey) == null){
			responseObserver.onNext(response);
			responseObserver.onCompleted();
			return;
		}
		for (Announcement announcement: this.privateBoard.get(userKey)) {
			if(announcement.equals(testingAnnouncement)){
				response = Contract.TestsResponse.newBuilder().setTestResult(true).build();
				break;
			}

		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneralState(Contract.PostRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		String[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());
		long writeTimeStamp = request.getFreshness();

		String announcementID = getAnnouncementId(userKey, request.getFreshness(), generalBoardId);
		Announcement testingAnnouncement = new Announcement(post, userKey,announcements, announcementID, null , writeTimeStamp, generalBoardId, new HashMap<>());

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(false).build();

		for (Announcement announcement: this.generalBoard) {
			if(announcement.equals(testingAnnouncement)){
				response = Contract.TestsResponse.newBuilder().setTestResult(true).build();
			}
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void cleanPosts(Empty request, StreamObserver<Empty> responseObserver) {
		this.privateBoard = new ConcurrentHashMap<>();
		this.announcementIDs = new ConcurrentHashMap<>();
		this.authenticatedDoubleEchoBroadcasts = new HashMap<>();
		this.clientReadFreshness = new ConcurrentHashMap<>();
		this.clientWriteFreshness = new ConcurrentHashMap<>();
		try{
			save("posts");
		}catch (DatabaseException e){
			e.getCause();
		}
		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void cleanGeneralPosts(Empty request, StreamObserver<Empty> responseObserver) {
		this.generalBoard = new ArrayList<>();
		this.announcementIDs = new ConcurrentHashMap<>();
		this.authenticatedDoubleEchoBroadcasts = new HashMap<>();
		this.clientReadFreshness = new ConcurrentHashMap<>();
		this.clientWriteFreshness = new ConcurrentHashMap<>();
		try{
			save("generalPosts");
		}catch (DatabaseException e){
			e.getCause();
		}
		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	public void registerTestClient(Contract.RegisterRequest request){
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());

		/* Registering client */
		this.clientReadFreshness.put(userKey, new FreshnessHandler());
		this.clientWriteFreshness.put(userKey, new FreshnessHandler());
		this.privateBoard.put(userKey, new ArrayList<>());
	}

	public AuthenticatedDoubleEchoBroadcast getADEB(RequestType request){
		return authenticatedDoubleEchoBroadcasts.get(request);
	}
}

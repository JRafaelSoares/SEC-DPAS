package pt.ulisboa.tecnico.SECDPAS;

/* these are generated by the Contract */
import SECDPAS.grpc.Contract;
import SECDPAS.grpc.DPASServiceGrpc;
import com.google.protobuf.ByteString;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import org.apache.commons.lang3.SerializationUtils;

import java.security.PublicKey;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class DPASServiceImpl extends DPASServiceGrpc.DPASServiceImplBase {

	private ConcurrentHashMap<PublicKey, CopyOnWriteArrayList<Announcement>> privateBoard = new ConcurrentHashMap<>();

	private CopyOnWriteArrayList<Announcement> generalBoard = new CopyOnWriteArrayList<>();

	@Override
	public void greeting(Contract.HelloRequest request, StreamObserver<Contract.HelloResponse> responseOberserver){
		Contract.HelloResponse response = Contract.HelloResponse.newBuilder().setGreeting("OLA").build();

		responseOberserver.onNext(response);
		responseOberserver.onCompleted();
	}

	@Override
	public void register(Contract.RegisterRequest request, StreamObserver<Empty> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		if(this.privateBoard.get(userKey) != null){
			responseObserver.onError(new ServerAlreadyRegistredException("Client is already registered"));
			return;
		}
		this.privateBoard.put(userKey, new CopyOnWriteArrayList<>());

		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void post(Contract.PostRequest request, StreamObserver<Empty> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		CopyOnWriteArrayList<Announcement> announcementList = this.privateBoard.get(userKey);

		if(announcementList == null){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}else{
			announcementList.add(new Announcement(post, userKey, announcements));
		}
		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneral(Contract.PostRequest request, StreamObserver<Empty> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		if(!this.privateBoard.containsKey(userKey)){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}
		//TODO- Announcement can be null, mby test for it? Add try catch?
		this.generalBoard.add(new Announcement(post, userKey, announcements));

		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void read(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		int numPosts = request.getNumber();

		CopyOnWriteArrayList<Announcement> announcementList = this.privateBoard.get(userKey);

		if(announcementList == null){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}

		Contract.ReadResponse response;
		if(numPosts == 0 || numPosts > announcementList.size()){
			//desirializes the array and transforms it to gRPC
			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(announcementList.toArray()))).build();
		}
		else{
			List<Announcement> toSent =  announcementList.subList(announcementList.size()-numPosts, announcementList.size());
			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(toSent.toArray()))).build();
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void readGeneral(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.toByteArray());
		int numPosts = request.getNumber();

		if(!this.privateBoard.containsKey(userKey)){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
		}

		Contract.ReadResponse response;
		if(numPosts == 0 || numPosts > this.generalBoard.size()){
			//desirializes the array and transforms it to gRPC
			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(this.generalBoard.toArray()))).build();
		}

		else{
			//TODO - Check if subList is done correctly
			List<Announcement> toSent =  this.generalBoard.subList(this.generalBoard.size()-numPosts, this.generalBoard.size());
			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(toSent.toArray()))).build();
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}
}

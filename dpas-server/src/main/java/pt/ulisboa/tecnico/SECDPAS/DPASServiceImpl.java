package pt.ulisboa.tecnico.SECDPAS;

/* these are generated by the Contract */
import SECDPAS.grpc.Contract;
import SECDPAS.grpc.DPASServiceGrpc;
import com.google.protobuf.ByteString;
import com.google.protobuf.Empty;
import io.grpc.stub.StreamObserver;
import org.apache.commons.lang3.SerializationUtils;

import java.security.PublicKey;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;

public class DPASServiceImpl extends DPASServiceGrpc.DPASServiceImplBase {

	private ConcurrentHashMap<PublicKey, ArrayList<Announcement>> privateBoard = new ConcurrentHashMap<>();

	private CopyOnWriteArrayList<Announcement> generalBoard = new CopyOnWriteArrayList<>();

	@Override
	public void greeting(Contract.HelloRequest request, StreamObserver<Contract.HelloResponse> responseOberserver){
		Contract.HelloResponse response = Contract.HelloResponse.newBuilder().setGreeting("OLA").build();

		responseOberserver.onNext(response);
		responseOberserver.onCompleted();
	}

	@Override
	public void register(Contract.RegisterRequest request, StreamObserver<Empty> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		if(this.privateBoard.get(userKey) != null){
			responseObserver.onError(new ServerAlreadyRegistredException("Client is already registered"));
			return;
		}
		this.privateBoard.put(userKey, new ArrayList<>());

		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void post(Contract.PostRequest request, StreamObserver<Empty> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		ArrayList<Announcement> announcementList = this.privateBoard.get(userKey);

		if(announcementList == null){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}else{
			announcementList.add(new Announcement(post, userKey, announcements));
		}
		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneral(Contract.PostRequest request, StreamObserver<Empty> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		if(!this.privateBoard.containsKey(userKey)){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}
		//TODO- Announcement can be null, mby test for it? Add try catch?
		this.generalBoard.add(new Announcement(post, userKey, announcements));

		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void read(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		int numPosts = request.getNumber();

		ArrayList<Announcement> announcementList = this.privateBoard.get(userKey);

		if(announcementList == null){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}

		Contract.ReadResponse response;
		if(numPosts == 0 || numPosts > announcementList.size()){
			//desirializes the array and transforms it to gRPC
			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(announcementList.toArray(new Announcement[0])))).build();
		}
		else{
			List<Announcement> toSent =  announcementList.subList(announcementList.size()-numPosts, announcementList.size());
			Announcement[] announcements = toSent.toArray(new Announcement[0]);

			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(announcements))).build();
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void readGeneral(Contract.ReadRequest request, StreamObserver<Contract.ReadResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		int numPosts = request.getNumber();

		if(!this.privateBoard.containsKey(userKey)){
			responseObserver.onError(new ServerNotRegistredException("Client not yet registered"));
			return;
		}

		Contract.ReadResponse response;
		if(numPosts == 0 || numPosts > this.generalBoard.size()){
			//desirializes the array and transforms it to gRPC
			Announcement[] array = this.generalBoard.toArray(new Announcement[0]);
			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(array))).build();
		}

		else{
			//TODO - Check if subList is done correctly
			List<Announcement> toSent =  this.generalBoard.subList(this.generalBoard.size()-numPosts, this.generalBoard.size());
			response = Contract.ReadResponse.newBuilder().setAnnouncements(ByteString.copyFrom(SerializationUtils.serialize(toSent.toArray(new Announcement[0] )))).build();
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	/**********************/
	/** TESTING FUNCTION **/
	/**********************/

	@Override
	public void clientRegisteredState(Contract.RegisterRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());

		boolean isUserRegistred = privateBoard.containsKey(userKey);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(isUserRegistred).build();

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postState(Contract.PostRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		Announcement testingAnnouncement = new Announcement(post, userKey, announcements);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(false).build();

		for (Announcement announcement: this.privateBoard.get(userKey)) {
			if(announcement.equals(testingAnnouncement)){
				response = Contract.TestsResponse.newBuilder().setTestResult(true).build();
				break;
			}
		}
		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void postGeneralState(Contract.PostRequest request, StreamObserver<Contract.TestsResponse> responseObserver) {
		char[] post = request.getMessage().toCharArray();
		PublicKey userKey = SerializationUtils.deserialize(request.getPublicKey().toByteArray());
		Announcement[] announcements = SerializationUtils.deserialize(request.getAnnouncements().toByteArray());

		Announcement testingAnnouncement = new Announcement(post, userKey, announcements);

		Contract.TestsResponse response = Contract.TestsResponse.newBuilder().setTestResult(false).build();

		for (Announcement announcement: this.generalBoard) {
			if(announcement.equals(testingAnnouncement)){
				response = Contract.TestsResponse.newBuilder().setTestResult(true).build();
			}
		}

		responseObserver.onNext(response);
		responseObserver.onCompleted();
	}

	@Override
	public void cleanPosts(Empty request, StreamObserver<Empty> responseObserver) {
		this.privateBoard = new ConcurrentHashMap<>();

		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}

	@Override
	public void cleanGeneralPosts(Empty request, StreamObserver<Empty> responseObserver) {
		this.generalBoard = new CopyOnWriteArrayList<>();

		responseObserver.onNext(Empty.newBuilder().build());
		responseObserver.onCompleted();
	}
}

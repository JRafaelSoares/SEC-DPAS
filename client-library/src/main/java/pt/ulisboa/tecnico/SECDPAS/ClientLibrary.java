package pt.ulisboa.tecnico.SECDPAS;

/* these are generated by the hello-world-server contract */
import SECDPAS.grpc.Contract;
import SECDPAS.grpc.DPASServiceGrpc;

import com.google.common.primitives.Bytes;
import com.google.common.primitives.Ints;
import com.google.protobuf.Empty;

import com.google.protobuf.ByteString;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import org.apache.commons.lang3.SerializationUtils;

import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SignatureException;

public class ClientLibrary {

	private String host = "localhost";
	private int port = 8080;
	private String target = host + ":" + port;

	private ManagedChannel channel;
	private DPASServiceGrpc.DPASServiceBlockingStub stub;
	private MessageHandler messageHandler;

	private PublicKey publicKey;
	private PrivateKey privateKey;

	public ClientLibrary(String host, int port, PublicKey publicKey, PrivateKey privateKey) throws InvalidArgumentException{
		checkConstructor(host, port, publicKey, privateKey);

		this.target = host + ":" + port;
		this.channel = ManagedChannelBuilder.forTarget(target).usePlaintext().build();
		this.stub = DPASServiceGrpc.newBlockingStub(channel);
		this.messageHandler = new MessageHandler(null);
		this.publicKey = publicKey;
		this.privateKey = privateKey;
	}

	public void register() throws ClientAlreadyRegisteredException {
		//Serializes key and changes to ByteString
		byte[] publicKey = SerializationUtils.serialize(this.publicKey);
		byte[] freshness = messageHandler.getFreshness();
		byte[] signature = SignatureHandler.publicSign(Bytes.concat(publicKey, freshness), privateKey);

		Contract.RegisterRequest request = Contract.RegisterRequest.newBuilder().setPublicKey(ByteString.copyFrom(publicKey)).setFreshness(ByteString.copyFrom(freshness)).setSignature(ByteString.copyFrom(signature)).build();
		try{
			Contract.ACK response = stub.register(request);
			messageHandler.verifyFreshness(response.getFreshness().toByteArray());
			//TODO- Distribute server key to clients
			//SignatureHandler.verifyPublicSignature(response.getFreshness(), response.getSignature(), serverKey);
		} catch (RuntimeException e){
			throw new ClientAlreadyRegisteredException(e.getMessage());
		} catch (MessageNotFreshException e) {
			System.out.println("Message not fresh");
		}
	}

	protected void setupConnection() throws ClientNotRegisteredException{
		// Create Diffie-Hellman agreement
		DiffieHellmanClient diffieHellmanClient = new DiffieHellmanClient();

		byte[] clientAgreement = null;

		try {
			clientAgreement = diffieHellmanClient.prepareAgreement();
		} catch (SignatureException e) {
			//TODO- Proper exceptions for client side
			e.printStackTrace();
		}

		// Serializes key and changes to ByteString
		byte[] publicKey = SerializationUtils.serialize(this.publicKey);

		byte[] freshness = messageHandler.getFreshness();
		byte[] signature = SignatureHandler.publicSign(Bytes.concat(publicKey, clientAgreement, freshness), privateKey);

		Contract.DHRequest request = Contract.DHRequest.newBuilder().setPublicKey(ByteString.copyFrom(publicKey)).setClientAgreement(ByteString.copyFrom(clientAgreement)).setFreshness(ByteString.copyFrom(freshness)).setSignature(ByteString.copyFrom(signature)).build();

		Contract.DHResponse response;
		try{
			response = stub.setupConnection(request);
		}catch (RuntimeException e){
			throw new ClientNotRegisteredException(e.getMessage());
		}

		byte[] serverAgreement = response.getServerAgreement().toByteArray();

		// First check if message is fresh and if it's signature is valid
		byte[] serverFreshness = response.getFreshness().toByteArray();

		try {
			messageHandler.verifyFreshness(serverFreshness);
		} catch (MessageNotFreshException e) {
			//TODO- Handle exceptions properly
			e.printStackTrace();
		}

		byte[] serverSignature = response.getSignature().toByteArray();

		//TODO- Provide server key to clients
		//SignatureHandler.verifyPublicSignature(Bytes.concat(serverAgreement, serverFreshness), serverKey);


		diffieHellmanClient.execute(response.getServerAgreement().toByteArray());

		messageHandler.resetSignature(diffieHellmanClient.getSharedHMACKey());
	}

	public void post(char[] message) throws InvalidArgumentException, ClientNotRegisteredException {
		checkMessage(message);

		post(message, new Announcement[0]);
	}

	public void post(char[] message, Announcement[] references) throws InvalidArgumentException, ClientNotRegisteredException {
		checkMessage(message);

		if(!messageHandler.isInSession()){
			setupConnection();
		}

		try{
			Contract.ACK response = stub.post(getPostRequest(message, references));
			messageHandler.verifyMessage(new byte[0], response.getFreshness().toByteArray(), response.getSignature().toByteArray());
		} catch (RuntimeException e){
			throw new ClientNotRegisteredException(e.getMessage());
		} catch (SignatureNotValidException | MessageNotFreshException e) {
			//TODO- Handle exceptions properly
			e.printStackTrace();
		}
	}

	public void postGeneral(char[] message) throws InvalidArgumentException, ClientNotRegisteredException {
		checkMessage(message);

			postGeneral(message, new Announcement[0]);
	}


	public void postGeneral(char[] message, Announcement[] references) throws InvalidArgumentException, ClientNotRegisteredException {
		checkMessage(message);

		if(!messageHandler.isInSession()){
			setupConnection();
		}

		try{
			Contract.ACK response = stub.postGeneral(getPostRequest(message, references));
			messageHandler.verifyMessage(new byte[0], response.getFreshness().toByteArray(), response.getSignature().toByteArray());
		} catch (RuntimeException e){
			throw new ClientNotRegisteredException(e.getMessage());
		} catch (SignatureNotValidException | MessageNotFreshException e) {
			//TODO- Handle exceptions properly
			e.printStackTrace();
		}
	}

	public Announcement[] read(int number) throws ClientNotRegisteredException, InvalidArgumentException {
		checkNumber(number);

		if(!messageHandler.isInSession()){
			setupConnection();
		}

		try {
			Contract.ReadResponse response = stub.read(getReadRequest(number));
			messageHandler.verifyMessage(response.getAnnouncements().toByteArray(), response.getFreshness().toByteArray(), response.getSignature().toByteArray());
			return SerializationUtils.deserialize(response.getAnnouncements().toByteArray());
		} catch (RuntimeException e){
			throw new ClientNotRegisteredException(e.getMessage());
		} catch (SignatureNotValidException | MessageNotFreshException e) {
			//TODO- Handle exceptions properly
			e.printStackTrace();
			return null;
		}
	}

	public Announcement[] readGeneral(int number) throws ClientNotRegisteredException, InvalidArgumentException {
		checkNumber(number);

		if(!messageHandler.isInSession()){
			setupConnection();
		}

		try {
			Contract.ReadResponse response = stub.readGeneral(getReadRequest(number));
			messageHandler.verifyMessage(response.getAnnouncements().toByteArray(), response.getFreshness().toByteArray(), response.getSignature().toByteArray());
			return SerializationUtils.deserialize(response.getAnnouncements().toByteArray());
		} catch (RuntimeException e){
			throw new ClientNotRegisteredException(e.getMessage());
		} catch (SignatureNotValidException | MessageNotFreshException e) {
			//TODO- Handle exceptions properly
			e.printStackTrace();
			return null;
		}
	}

	/*************************/
	/**** AUX FUNCTIONS ******/
	/*************************/

	public Contract.PostRequest getPostRequest(char[] message, Announcement[] references) {
		byte[] publicKey = SerializationUtils.serialize(this.publicKey);
		String post = new String(message);
		byte[] postBytes = post.getBytes();
		byte[] announcements = SerializationUtils.serialize(references);

		byte[] freshness = messageHandler.getFreshness();
		byte[] signature = messageHandler.sign(Bytes.concat(publicKey, postBytes, announcements), freshness);

		return Contract.PostRequest.newBuilder().setPublicKey(ByteString.copyFrom(publicKey)).setMessage(post).setAnnouncements(ByteString.copyFrom(announcements)).setFreshness(ByteString.copyFrom(freshness)).setSignature(ByteString.copyFrom(signature)).build();
	}

	public Contract.PostRequest getTestPostRequest(char[] message, Announcement[] references) {
		byte[] publicKey = SerializationUtils.serialize(this.publicKey);
		String post = new String(message);
		byte[] announcements = SerializationUtils.serialize(references);

		return Contract.PostRequest.newBuilder().setPublicKey(ByteString.copyFrom(publicKey)).setMessage(post).setAnnouncements(ByteString.copyFrom(announcements)).build();
	}

	public Contract.ReadRequest getReadRequest(int number){
		byte[] publicKey = SerializationUtils.serialize(this.publicKey);
		byte[] numberBytes = Ints.toByteArray(number);
		byte[] freshness = messageHandler.getFreshness();
		byte[] signature = messageHandler.sign(Bytes.concat(publicKey, numberBytes), freshness);

		return Contract.ReadRequest.newBuilder().setPublicKey(ByteString.copyFrom(publicKey)).setNumber(number).setFreshness(ByteString.copyFrom(freshness)).setSignature(ByteString.copyFrom(signature)).build();

	}

	public Contract.RegisterRequest getRegisterRequest(){
		byte[] publicKey = SerializationUtils.serialize(this.publicKey);
		byte[] freshness = messageHandler.getFreshness();
		byte[] signature = SignatureHandler.publicSign(Bytes.concat(publicKey, freshness), privateKey);

		return Contract.RegisterRequest.newBuilder().setPublicKey(ByteString.copyFrom(publicKey)).setFreshness(ByteString.copyFrom(freshness)).setSignature(ByteString.copyFrom(signature)).build();
	}

	/********************/
	/** TEST FUNCTIONS **/
	/********************/

	public boolean clientRegisteredState() {
		ByteString publicKey = ByteString.copyFrom(SerializationUtils.serialize(this.publicKey));
		Contract.RegisterRequest request = Contract.RegisterRequest.newBuilder().setPublicKey(publicKey).build();

		Contract.TestsResponse response = stub.clientRegisteredState(request);

		return response.getTestResult();
	}

	public boolean postState(char[] message, Announcement[] references) {
		try{
			checkMessage(message);

			Contract.TestsResponse response = stub.postState(getTestPostRequest(message, references));
			return response.getTestResult();
		} catch (InvalidArgumentException e){
			return false;
		}
	}

	public boolean postState(char[] message) {
		try{
			checkMessage(message);

			return postState(message, new Announcement[0]);
		}catch (InvalidArgumentException e){
			return false;
		}
	}

	public boolean postGeneralState(char[] message, Announcement[] references) {
		try{
			checkMessage(message);

			Contract.TestsResponse response = stub.postGeneralState(getTestPostRequest(message, references));
			return response.getTestResult();
		} catch (InvalidArgumentException e){
			return false;
		}
	}

	public boolean postGeneralState(char[] message) {
		try{
			checkMessage(message);

			return postGeneralState(message, new Announcement[0]);
		}catch (InvalidArgumentException e){
			return false;
		}
	}

	public void postRequest(Contract.PostRequest request) throws ClientNotRegisteredException, SignatureNotValidException, MessageNotFreshException{
		try{
			Contract.ACK response = stub.post(request);
			messageHandler.verifyMessage(new byte[0], response.getFreshness().toByteArray(), response.getSignature().toByteArray());
		} catch (RuntimeException e){
			throw new ClientNotRegisteredException(e.getMessage());
		}
	}

	public void postGeneralRequest(Contract.PostRequest request) throws ClientNotRegisteredException, SignatureNotValidException, MessageNotFreshException{
		try{
			Contract.ACK response = stub.postGeneral(request);
			messageHandler.verifyMessage(new byte[0], response.getFreshness().toByteArray(), response.getSignature().toByteArray());
		} catch (RuntimeException e){
			throw new ClientNotRegisteredException(e.getMessage());
		}
	}

	public Announcement[] readRequest(Contract.ReadRequest request) throws ClientNotRegisteredException ,SignatureNotValidException, MessageNotFreshException {
		try {
			Contract.ReadResponse response = stub.read(request);
			messageHandler.verifyMessage(response.getAnnouncements().toByteArray(), response.getFreshness().toByteArray(), response.getSignature().toByteArray());
			return SerializationUtils.deserialize(response.getAnnouncements().toByteArray());
		} catch (RuntimeException e){
			throw new ClientNotRegisteredException(e.getMessage());
		}
	}

	public Announcement[] readGeneralRequest(Contract.ReadRequest request) throws ClientNotRegisteredException ,SignatureNotValidException, MessageNotFreshException {
		try {
			Contract.ReadResponse response = stub.readGeneral(request);
			messageHandler.verifyMessage(response.getAnnouncements().toByteArray(), response.getFreshness().toByteArray(), response.getSignature().toByteArray());
			return SerializationUtils.deserialize(response.getAnnouncements().toByteArray());
		} catch (RuntimeException e){
			throw new ClientNotRegisteredException(e.getMessage());
		}
	}

	public void registerRequest(Contract.RegisterRequest request) throws ClientAlreadyRegisteredException, MessageNotFreshException {
		try{
			Contract.ACK response = stub.register(request);
			messageHandler.verifyFreshness(response.getFreshness().toByteArray());
			//TODO- Distribute server key to clients
			//SignatureHandler.verifyPublicSignature(response.getFreshness(), response.getSignature(), serverKey);
		} catch (RuntimeException e){
			throw new ClientAlreadyRegisteredException(e.getMessage());
		}
	}

	public void cleanPosts(){
		stub.cleanPosts(Empty.newBuilder().build());
	}

	public void cleanGeneralPosts(){
		stub.cleanGeneralPosts(Empty.newBuilder().build());
	}

	/*********************/
	/** CHECK ARGUMENTS **/
	/*********************/

	private void checkConstructor(String host, int port, PublicKey publicKey, PrivateKey privateKey) throws InvalidArgumentException {
		if(host == null || host.isEmpty() || port < 0 || publicKey == null || privateKey == null){
			throw new InvalidArgumentException("Invalid constructor arguments");
		}
	}

	private void checkMessage(char[] message) throws InvalidArgumentException {
		if(message == null){
			throw new InvalidArgumentException("Public key can not be null");
		}
		if(message.length > 255) {
			throw new InvalidArgumentException("Post too long, must be smaller than 256 chars");
		}
	}

	private void checkNumber(int n) throws InvalidArgumentException {
		if(n < 0){
			throw new InvalidArgumentException("Number can not be negative");
		}
	}


}
